Description: Upstream changes introduced in version 0.7-1
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 awesant (0.7-1) unstable; urgency=low
 .
   * Initial release.
 .
 The person named in the Author field signed this changelog entry.
Author: Jonny Schulz <js@bloonix.de>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- awesant-0.7.orig/ChangeLog
+++ awesant-0.7/ChangeLog
@@ -1,6 +1,7 @@
-awesant (0.7) released at XXXX-XX-XX
+awesant (0.7) released at 2013-02-03
 
     * Some readability improvements.
+    * Now it's possible to build awesant for debian.
 
 awesant (0.6) released at 2013-01-05
 
--- awesant-0.7.orig/Makefile.config
+++ awesant-0.7/Makefile.config
@@ -1,5 +1,5 @@
 # Base paths
-PREFIX=$(DESTDIR)/usr/local
+PREFIX=$(DESTDIR)/usr
 CONFDIR=$(DESTDIR)/etc
 INITDIR=$(DESTDIR)/etc/init.d
 LOGDIR=$(DESTDIR)/var/log
@@ -7,4 +7,4 @@ RUNDIR=$(DESTDIR)/var/run
 PERL=/usr/bin/perl
 PERL_INSTALLDIRS=site
 PERL_DESTDIR=$(DESTDIR)
-WITHOUT_PERL=0
+WITHOUT_PERL=1
--- /dev/null
+++ awesant-0.7/perl/Build
@@ -0,0 +1,57 @@
+#! /usr/bin/perl
+
+use strict;
+use Cwd;
+use File::Basename;
+use File::Spec;
+
+sub magic_number_matches {
+  return 0 unless -e '_build/magicnum';
+  local *FH;
+  open FH, '_build/magicnum' or return 0;
+  my $filenum = <FH>;
+  close FH;
+  return $filenum == 660243;
+}
+
+my $progname;
+my $orig_dir;
+BEGIN {
+  $^W = 1;  # Use warnings
+  $progname = basename($0);
+  $orig_dir = Cwd::cwd();
+  my $base_dir = '/home/bloonix/awesant-0.7/perl';
+  if (!magic_number_matches()) {
+    unless (chdir($base_dir)) {
+      die ("Couldn't chdir($base_dir), aborting\n");
+    }
+    unless (magic_number_matches()) {
+      die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\n");
+    }
+  }
+  unshift @INC,
+    (
+
+    );
+}
+
+close(*DATA) unless eof(*DATA); # ensure no open handles to this script
+
+use Module::Build;
+
+# Some platforms have problems setting $^X in shebang contexts, fix it up here
+$^X = Module::Build->find_perl_interpreter;
+
+if (-e 'Build.PL' and not Module::Build->up_to_date('Build.PL', $progname)) {
+   warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\n";
+}
+
+# This should have just enough arguments to be able to bootstrap the rest.
+my $build = Module::Build->resume (
+  properties => {
+    config_dir => '_build',
+    orig_dir => $orig_dir,
+  },
+);
+
+$build->dispatch;
--- /dev/null
+++ awesant-0.7/perl/_build/auto_features
@@ -0,0 +1,2 @@
+do{ my $x = {};
+$x; }
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/_build/notes
@@ -0,0 +1,2 @@
+do{ my $x = {};
+$x; }
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/_build/config_data
@@ -0,0 +1,2 @@
+do{ my $x = {};
+$x; }
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/_build/runtime_params
@@ -0,0 +1,6 @@
+do{ my $x = {
+       'create_packlist' => '0',
+       'installdirs' => 'vendor',
+       'destdir' => '/home/bloonix/awesant-0.7/debian/awesant'
+     };
+$x; }
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/_build/magicnum
@@ -0,0 +1 @@
+660243
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/_build/features
@@ -0,0 +1,2 @@
+do{ my $x = {};
+$x; }
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/_build/build_params
@@ -0,0 +1,278 @@
+do{ my $x = [
+       {
+         'ARGV' => []
+       },
+       {},
+       {
+         'verbose' => undef,
+         'PL_files' => undef,
+         'pollute' => undef,
+         'bindoc_dirs' => [
+                            'blib/script'
+                          ],
+         'conflicts' => {},
+         'recommends' => {},
+         'scripts' => undef,
+         'dist_version' => '0.6',
+         'pod_files' => undef,
+         'config_dir' => '_build',
+         'recurse_into' => [],
+         'build_bat' => 0,
+         'sign' => 0,
+         'extra_linker_flags' => [],
+         'build_class' => 'Module::Build',
+         'prereq_action_types' => [
+                                    'requires',
+                                    'build_requires',
+                                    'conflicts',
+                                    'recommends'
+                                  ],
+         'base_dir' => '/home/bloonix/awesant-0.7/perl',
+         'allow_mb_mismatch' => 0,
+         'xs_files' => undef,
+         'destdir' => undef,
+         'metafile' => 'META.yml',
+         'mb_version' => '0.340201',
+         'use_tap_harness' => 0,
+         'test_file_exts' => [
+                               '.t'
+                             ],
+         'has_config_data' => undef,
+         'dist_name' => 'Awesant-Agent',
+         'install_base' => undef,
+         'module_name' => 'Awesant::Agent',
+         'recursive_test_files' => undef,
+         'libdoc_dirs' => [
+                            'blib/lib',
+                            'blib/arch'
+                          ],
+         'perl' => '/usr/bin/perl',
+         'dist_author' => [
+                            'Jonny Schulz'
+                          ],
+         'use_rcfile' => 1,
+         'configure_requires' => {},
+         'test_files' => undef,
+         'dist_abstract' => undef,
+         'create_readme' => undef,
+         'prefix_relpaths' => {
+                                'core' => {
+                                            'libdoc' => [
+                                                          'man',
+                                                          'man3'
+                                                        ],
+                                            'script' => [
+                                                          'bin'
+                                                        ],
+                                            'libhtml' => [
+                                                           'html'
+                                                         ],
+                                            'bindoc' => [
+                                                          'man',
+                                                          'man1'
+                                                        ],
+                                            'bin' => [
+                                                       'bin'
+                                                     ],
+                                            'arch' => [
+                                                        'lib',
+                                                        'perl5',
+                                                        '5.10.1',
+                                                        'x86_64-linux-gnu-thread-multi'
+                                                      ],
+                                            'binhtml' => [
+                                                           'html'
+                                                         ],
+                                            'lib' => [
+                                                       'lib',
+                                                       'perl5'
+                                                     ]
+                                          },
+                                'site' => {
+                                            'libdoc' => [
+                                                          'man',
+                                                          'man3'
+                                                        ],
+                                            'script' => [
+                                                          'bin'
+                                                        ],
+                                            'libhtml' => [
+                                                           'html'
+                                                         ],
+                                            'bindoc' => [
+                                                          'man',
+                                                          'man1'
+                                                        ],
+                                            'bin' => [
+                                                       'bin'
+                                                     ],
+                                            'arch' => [
+                                                        'lib',
+                                                        'perl5',
+                                                        'site_perl',
+                                                        '5.10.1',
+                                                        'x86_64-linux-gnu-thread-multi'
+                                                      ],
+                                            'binhtml' => [
+                                                           'html'
+                                                         ],
+                                            'lib' => [
+                                                       'lib',
+                                                       'perl5',
+                                                       'site_perl'
+                                                     ]
+                                          },
+                                'vendor' => {
+                                              'libdoc' => [
+                                                            'man',
+                                                            'man3'
+                                                          ],
+                                              'script' => [
+                                                            'bin'
+                                                          ],
+                                              'libhtml' => [
+                                                             'html'
+                                                           ],
+                                              'bindoc' => [
+                                                            'man',
+                                                            'man1'
+                                                          ],
+                                              'bin' => [
+                                                         'bin'
+                                                       ],
+                                              'arch' => [
+                                                          'lib',
+                                                          'perl5',
+                                                          '5.10.1',
+                                                          'x86_64-linux-gnu-thread-multi'
+                                                        ],
+                                              'binhtml' => [
+                                                             'html'
+                                                           ],
+                                              'lib' => [
+                                                         'lib',
+                                                         'perl5'
+                                                       ]
+                                            }
+                              },
+         'debug' => undef,
+         'meta_merge' => {},
+         'get_options' => {},
+         'dist_version_from' => 'lib/Awesant/Agent.pm',
+         'auto_configure_requires' => 1,
+         'create_license' => undef,
+         'debugger' => undef,
+         'html_css' => '',
+         'build_elements' => [
+                               'PL',
+                               'support',
+                               'pm',
+                               'xs',
+                               'pod',
+                               'script'
+                             ],
+         'orig_dir' => '/home/bloonix/awesant-0.7/perl',
+         'include_dirs' => [],
+         'installdirs' => 'vendor',
+         'create_makefile_pl' => 'traditional',
+         'magic_number' => undef,
+         'install_sets' => {
+                             'core' => {
+                                         'libdoc' => '/usr/share/man/man3',
+                                         'script' => '/usr/bin',
+                                         'libhtml' => undef,
+                                         'bindoc' => '/usr/share/man/man1',
+                                         'bin' => '/usr/bin',
+                                         'arch' => '/usr/lib/perl/5.10',
+                                         'binhtml' => undef,
+                                         'lib' => '/usr/share/perl/5.10'
+                                       },
+                             'site' => {
+                                         'libdoc' => '/usr/local/man/man3',
+                                         'script' => '/usr/local/bin',
+                                         'libhtml' => undef,
+                                         'bindoc' => '/usr/local/man/man1',
+                                         'bin' => '/usr/local/bin',
+                                         'arch' => '/usr/local/lib/perl/5.10.1',
+                                         'binhtml' => undef,
+                                         'lib' => '/usr/local/share/perl/5.10.1'
+                                       },
+                             'vendor' => {
+                                           'libdoc' => '/usr/share/man/man3',
+                                           'script' => '/usr/bin',
+                                           'libhtml' => undef,
+                                           'bindoc' => '/usr/share/man/man1',
+                                           'bin' => '/usr/bin',
+                                           'arch' => '/usr/lib/perl5',
+                                           'binhtml' => undef,
+                                           'lib' => '/usr/share/perl5'
+                                         }
+                           },
+         'tap_harness_args' => {},
+         'install_base_relpaths' => {
+                                      'libdoc' => [
+                                                    'man',
+                                                    'man3'
+                                                  ],
+                                      'script' => [
+                                                    'bin'
+                                                  ],
+                                      'libhtml' => [
+                                                     'html'
+                                                   ],
+                                      'bindoc' => [
+                                                    'man',
+                                                    'man1'
+                                                  ],
+                                      'bin' => [
+                                                 'bin'
+                                               ],
+                                      'arch' => [
+                                                  'lib',
+                                                  'perl5',
+                                                  'x86_64-linux-gnu-thread-multi'
+                                                ],
+                                      'binhtml' => [
+                                                     'html'
+                                                   ],
+                                      'lib' => [
+                                                 'lib',
+                                                 'perl5'
+                                               ]
+                                    },
+         'meta_add' => {},
+         'create_packlist' => 1,
+         'requires' => {
+                         'Fcntl' => 0,
+                         'Test::More' => 0,
+                         'perl' => '5.006_001',
+                         'Params::Validate' => 0,
+                         'IO::Select' => 0,
+                         'IO::Socket' => 0,
+                         'POSIX' => 0,
+                         'JSON' => 0,
+                         'Log::Handler' => '0.75',
+                         'Sys::Hostname' => 0
+                       },
+         'install_path' => {},
+         'pm_files' => undef,
+         'quiet' => undef,
+         'script_files' => undef,
+         'extra_compiler_flags' => [],
+         'build_script' => 'Build',
+         'original_prefix' => {
+                                'core' => '/usr',
+                                'site' => '/usr/local',
+                                'vendor' => '/usr'
+                              },
+         'c_source' => undef,
+         'autosplit' => undef,
+         'program_name' => undef,
+         'license' => 'perl',
+         'build_requires' => {},
+         'config' => undef,
+         'blib' => 'blib',
+         'prefix' => undef
+       }
+     ];
+$x; }
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/_build/cleanup
@@ -0,0 +1,4 @@
+do{ my $x = {
+       'blib' => 1
+     };
+$x; }
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/_build/prereqs
@@ -0,0 +1,18 @@
+do{ my $x = {
+       'build_requires' => {},
+       'conflicts' => {},
+       'requires' => {
+                       'Fcntl' => 0,
+                       'Test::More' => 0,
+                       'perl' => '5.006_001',
+                       'Params::Validate' => 0,
+                       'IO::Select' => 0,
+                       'IO::Socket' => 0,
+                       'POSIX' => 0,
+                       'JSON' => 0,
+                       'Log::Handler' => '0.75',
+                       'Sys::Hostname' => 0
+                     },
+       'recommends' => {}
+     };
+$x; }
\ No newline at end of file
--- /dev/null
+++ awesant-0.7/perl/blib/lib/Awesant/Config.pm
@@ -0,0 +1,211 @@
+=head1 NAME
+
+Awesant::Config - Configuration file parser.
+
+=head1 SYNOPSIS
+
+    my $config = Awesant::Config->parse($file);
+
+=head1 DESCRIPTION
+
+This module is just for internal usage.
+
+=head1 CONFIGURATION FORMAT
+
+=head2 SELF-EXPLANATORY
+
+The configuration format is very simple:
+
+    param1 value
+    param2 value
+    param3 " value value value "
+    param4 ' value value value '
+    param5 multiline \
+           value
+    param6 " multiline values " \
+           " with whitespaces "
+
+    section1 {
+        param1 value
+        param2 value
+
+        subsection1 {
+            param1 value
+            param2 value
+        }
+    }
+
+=head2 COMMENTS
+
+Add comments to the configuration to explain parameter:
+
+    # Comment
+    param1 value # comment
+    param2 value#value # comment
+    param3 'value \# value' # comment
+    param4 multiline \ # comment
+           value
+    param5 " multiline values " \ # comment
+           " with whitespaces " # comment
+
+=head2 HASHES VS ARRRAYS
+
+Please note that if a hash key exists that the values will be pushed into an array:
+
+    param1 value
+    param2 value1
+    param2 value2
+
+    section1 {
+        param value
+    }
+    section2 {
+        param value
+    }
+    section2 {
+        param value
+    }
+
+is
+
+    param1 => "value",
+    param2 => [ "value1", "value2" ],
+    section1 => { param => "value" },
+    section2 => [
+        { param => "value" },
+        { param => "value" }
+    ]
+
+=head1 FUNCTIONS
+
+=head2 C<parse>
+
+Pass the configuration file as argument and a hash reference with the
+parsed configuration will be returned.
+
+=head1 PREREQUISITES
+
+No prerequisites.
+
+=head1 EXPORTS
+
+No exports.
+
+=head1 REPORT BUGS
+
+Please report all bugs to <support(at)bloonix.de>.
+
+=head1 AUTHOR
+
+Jonny Schulz <support(at)bloonix.de>.
+
+=head1 COPYRIGHT
+
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
+
+=cut
+
+package Awesant::Config;
+
+use strict;
+use warnings;
+
+sub parse {
+    my ($class, $file) = @_;
+
+    open my $fh, "<", $file
+        or die "Unable to open file '$file' for reading - $!";
+
+    my $config = { };
+
+    $class->_parse_config($fh, $config);
+
+    close $fh;
+    return $config;
+}
+
+sub _parse_config {
+    my ($self, $fh, $config) = @_;
+    my ($key, $value, @multiline, $is_multiline);
+
+    while (my $line = <$fh>) {
+        # Prepare the line and cut newline, comments
+        # and whitespaces from the begin and the end
+        # of each line.
+        $line =~ s/[\r\n]+\z//;
+        $line =~ s/^\s*#.*//;
+        $line =~ s/\s+#.+//;
+        $line =~ s/\\#/#/g;
+        $line =~ s/^\s+//;
+        $line =~ s/\s+\z//;
+
+        # Comments and whitespaces was removed.
+        # Empty lines will be ignored.
+        if (!length $line) {
+            next;
+        }
+
+        # The end of a section ends with "}"
+        if ($line =~ /^\s*\}/) {
+            return;
+        }
+
+        # If the parameter was marked as multiline parameter
+        # then the raw line will be stored as value.
+        if ($is_multiline) {
+            $value = $line;
+        }
+
+        # If a line begins with "keyword {" then it's a sub-section.
+        elsif ($line =~ /^([^\s]+)\s*\{/) {
+            ($key, $value) = ($1, { });
+            $self->_add_key_value($config, $key, $value);
+            $self->_parse_config($fh, $value);
+            next;
+        }
+
+        # A key value pair. The value can be an empty string.
+        elsif ($line =~ /^([^\s]+)\s*(.*)/) {
+            ($key, $value) = ($1, $2);
+        }
+
+        # Look if the end of the line is marked as multiline.
+        $is_multiline = $value =~ s/\s*\\\z//;
+
+        # Remove the quotes of quoted values.
+        if ($value =~ /^'(.*)'\z/ || $value =~ /^"(.*)"\z/) {
+            $value = $1;
+        }
+
+        # If the line is marked as multiline, then just
+        # push the value into a temporary array.
+        if ($is_multiline) {
+            push @multiline, $value;
+            next;
+        }
+
+        # If the last parsed parameter was a multine parameter,
+        # then the array @multiline contains the values.
+        if (@multiline) {
+            $value = join(" ", @multiline, $value);
+            @multiline = ();
+        }
+
+        # Add the key value pair to the config.
+        $self->_add_key_value($config, $key, $value);
+    }
+}
+
+sub _add_key_value {
+    my ($class, $config, $key, $value) = @_;
+
+    if (!exists $config->{$key}) {
+        $config->{$key} = $value;
+    } elsif (ref $config->{$key} eq "ARRAY") {
+        push @{$config->{$key}}, $value;
+    } else {
+        $config->{$key} = [ $config->{$key}, $value ];
+    }
+}
+
+1;
--- /dev/null
+++ awesant-0.7/perl/blib/lib/Awesant/Agent.pm
@@ -0,0 +1,966 @@
+=head1 NAME
+
+Awesant::Agent - Ships log files for logstash.
+
+=head1 SYNOPSIS
+
+    Awesant::Agent->run(
+        config  => $path_to_configuration,
+        pidfile => $path_to_pid_file,
+    );
+
+=head1 DESCRIPTION
+
+Awesant is a simple log file shipper for logstash.
+
+It ships log files and sends the data to different transports.
+
+All what you have to do is to call the method C<run> with its expected options.
+
+=head1 METHODS
+
+=head2 run
+
+Start the shipping machine.
+
+Nothing more is there for you to do. That means that you shouldn't touch the
+other methods in this module.
+
+=head2 load_output
+
+Load the output modules that are used by configuration.
+
+As example if C<redis> is defined as transport in the output section
+
+    output {
+        redis {
+            ...
+        }
+    }
+
+then Awesant is looking for a module called C<Awesant::Output::Redis>.
+If you would define a section call C<foo>, then Awesant would try to
+C<require> the module C<Awesant::Output::Foo>.
+
+=head2 load_input
+
+The method C<load_input> does in the first step the same like C<load_output>.
+It looks for input modules. As example if the input C<file> is configured,
+then it tries to load the module C<Awesant::Input::File>.
+
+As next each output module that was pre-loaded is bound to the inputs.
+This is done using the parameter C<type>.
+
+=head2 load_module
+
+This method just includes the input and output modules and is called by
+C<load_output> and C<load_input>. The process to load the modules is really
+simple.
+
+As example if the following sections are configured:
+
+    output {
+        redis {
+            ...
+        }
+    }
+
+then the module is loaded as follows:
+
+    my $input_or_output = "output"; # output is the first section
+    my $transport = "redis";        # redis is the configured transport
+
+    my $module = join("::",
+        "Awesant",
+        ucfirst($input_or_output),
+        ucfirst($transport)
+    );
+
+    require $module;
+
+All clear? :-)
+
+=head2 daemonize
+
+Start the endless loop and calls C<run_agent> in an eval block.
+
+=head2 run_agent
+
+This method is just a wrapper and calls C<run_log_shipper> in an eval block.
+
+=head2 run_server
+
+This methods creates some process groups for each input and just calls C<run_agent>
+for each group after the workers are forked.
+
+=head2 run_log_shipper
+
+The main logic of the Awesant agent. It requests the inputs for data to
+forward the data to the outputs.
+
+=head2 prepare_message
+
+Each log line is passed to C<prepare_message> and a nice formatted
+JSON string is returned, ready for Logstash.
+
+=head2 reap_children
+
+Reap died sub processes.
+
+=head2 spawn_children
+
+Fork new children if less children than the configured workers are running.
+
+=head2 kill_children
+
+Kill all children on signal term.
+
+=head2 sig_child_handler
+
+A handler to reap children.
+
+=head2 get_config
+
+Load the configuration from a file.
+
+=head2 write_pidfile
+
+Writes the PID file.
+
+=head2 remove_pidfile
+
+Removes the PID file.
+
+=head2 create_logger
+
+Create the logger object. As logger C<Log::Handler> is used.
+
+=head2 validate_config, validate_agent_config, validate_add_field_match
+
+Validate the configuration.
+
+=head2 config
+
+Just an accessor to the configuration.
+
+=head2 log
+
+Just an accessor to the logger.
+
+=head1 PREREQUISITES
+
+    Log::Handler
+    Params::Validate
+    JSON
+    POSIX
+    Sys::Hostname
+    Time::HiRes
+    Class::Accessor::Fast
+
+=head1 EXPORTS
+
+No exports.
+
+=head1 REPORT BUGS
+
+Please report all bugs to <support(at)bloonix.de>.
+
+=head1 AUTHOR
+
+Jonny Schulz <support(at)bloonix.de>.
+
+=head1 COPYRIGHT
+
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
+
+=cut
+
+package Awesant::Agent;
+
+use strict;
+use warnings;
+use Log::Handler;
+use Params::Validate qw();
+use JSON;
+use POSIX qw(:sys_wait_h);
+use Sys::Hostname;
+use Time::HiRes qw();
+use Awesant::Config;
+use base qw(Class::Accessor::Fast);
+
+# On Windows fork() is not really available.
+# If the agent will be started on windows
+# then awesant runs only as single process.
+# TODO: implement threading?
+use constant IS_WIN32 => $^O =~ /Win32/i;
+
+# Just some simple accessors
+__PACKAGE__->mk_accessors(qw/config log process_group json/);
+
+our $VERSION = "0.6";
+
+sub run {
+    my ($class, %args) = @_;
+
+    my $self = bless {
+        args     => \%args, # the command line arguments
+        done     => 0,      # a flag to stop the daemon on some signals
+        child    => { },    # store the pids of each child
+        reaped   => { },    # store the pids of each child that was reaped
+        inputs   => [ ],    # store the inputs in a array ref
+        outputs  => { },    # store the outputs in a hash ref by type
+        json     => JSON->new(),
+        hostname => Sys::Hostname::hostname(),
+    }, $class;
+
+    # The main workflow.
+    $self->write_pidfile;
+    $self->get_config;
+    $self->create_logger;
+    $self->load_output;
+    $self->load_input;
+    $self->daemonize;
+    $self->remove_pidfile;
+}
+
+sub load_output {
+    my $self = shift;
+    my $outputs = $self->config->{output};
+
+    foreach my $output (keys %$outputs) {
+        # At first the output module is required.
+        # Example: redis => Awesant/Output/Redis.pm
+        my $module = $self->load_module(output => $output);
+
+        foreach my $config (@{$outputs->{$output}}) {
+            # Option "type" is used by the agent and must be
+            # deleted from the output configuration.
+            my $types = delete $config->{type};
+
+            # Type is an mandatory parameter. The type is overwritten
+            # if incoming json_events has @type set.
+            if (!defined $types) {
+                die "missing mandatory parameter 'type' of output '$output'";
+            }
+
+            # Only a-zA-Z_0-9 is allowed.
+            if (!length $types) {
+                die "no value passed for parameter 'type' of output '$output'";
+            }
+
+            # Create a new output object.
+            my $object = $module->new($config);
+
+            # Multiple types are allowed for outputs.
+            foreach my $type (split /,/, $types) {
+                $type =~ s/^\s+//;
+                $type =~ s/\s+\z//;
+                push @{$self->{outputs}->{$type}}, $object;
+            }
+        }
+    }
+}
+
+sub load_input {
+    my $self = shift;
+    my $inputs = $self->config->{input};
+
+    foreach my $input (keys %$inputs) {
+        # At first load the input modules.
+        # Example: file => Awesant/Input/File.pm
+        my $module = $self->load_module(input => $input);
+
+        foreach my $config (@{$inputs->{$input}}) {
+
+            # Split the agent configuration parameter from the
+            # parameter for the input module.
+            my %agent_config;
+            foreach my $param (qw/type tags add_field workers format/) {
+                if (exists $config->{$param}) {
+                    $agent_config{$param} = delete $config->{$param};
+                }
+            }
+
+            # If the add_field value is a hash then it can contains code
+            # instead of a simple string. In this case the code must be
+            # executed for every json event.
+            foreach my $field (keys %{$agent_config{add_field}}) {
+                if (ref $agent_config{add_field}{$field} eq "HASH") {
+                    $agent_config{__add_field}{$field} = delete $agent_config{add_field}{$field};
+                }
+            }
+
+            # A path should be set.
+            $agent_config{path} = $config->{path} || "/";
+
+            # The file input can only process on single file, but if a wildcard
+            # is used within the path or a comma separated list of files is passed
+            # it's necessary to create an input object for each file.
+            if ($input eq "file") {
+                foreach my $path (split /,/, $config->{path}) {
+                    $path =~ s/^\s+//;
+                    $path =~ s/\s+\z//;
+                    while (my $file = glob $path) {
+                        my %c = %$config;
+                        my %a = %agent_config;
+                        $a{path} = $c{path} = $file;
+                        push @{$self->{inputs}}, {
+                            time   => scalar Time::HiRes::gettimeofday(),
+                            object => $module->new(\%c),
+                            config => $self->validate_agent_config(\%a),
+                        };
+                    }
+                }
+            } else {
+                push @{$self->{inputs}}, {
+                    time   => scalar Time::HiRes::gettimeofday(),
+                    object => $module->new($config),
+                    config => $self->validate_agent_config(\%agent_config),
+                };
+            }
+        }
+    }
+}
+
+sub load_module {
+    my ($self, $io, $type) = @_;
+
+    # output { redis { } }
+    #   = Awesant::Output::Redis
+    my $module = join("::",
+        "Awesant",
+        ucfirst($io),
+        ucfirst($type),
+    );
+
+    eval "require $module";
+
+    if ($@) {
+        # The module name may be uppercase.
+        # output { tcp { } }
+        #    = Awesant::Output::TCP
+        $module = join("::",
+            "Awesant",
+            ucfirst($io),
+            uc($type),
+        );
+        eval "require $module";
+        die $@ if $@;
+    }
+
+    return $module;
+}
+
+sub daemonize {
+    my $self = shift;
+
+    # For debugging.
+    $SIG{__DIE__}  = sub { $self->log->trace(error   => @_) };
+    $SIG{__WARN__} = sub { $self->log->trace(warning => @_) };
+
+    # Ignoring sig hup and pipe by default, because we have no
+    # reload mechanism and don't want to break on pipe signals.
+    $SIG{HUP} = $SIG{PIPE} = "IGNORE";
+
+    # If one of the following signals are catched then the daemon
+    # should stop normally and reap all children first.
+    $SIG{TERM} = $SIG{INT} = sub { $self->{done} = 1 };
+
+    if (IS_WIN32) {
+        $self->run_agent;
+    } else {
+        $self->run_server;
+    }
+}
+
+sub run_server {
+    my $self = shift;
+    my $child = $self->{child};
+    my $reaped = $self->{reaped};
+    my $group = 0;
+
+    # Split the inputs into process groups.
+    foreach my $input (@{$self->{inputs}}) {
+        if ($input->{config}->{workers}) {
+            $group++;
+            $self->{process_group}->{$group} = {
+                workers => $input->{config}->{workers},
+                inputs  => [ $input ],
+                child   => { },
+            };
+        } else {
+            $self->{process_group}->{0}->{workers} ||= 1;
+            $self->{process_group}->{0}->{child} ||= { };
+            push @{$self->{process_group}->{0}->{inputs}}, $input;
+        }
+    }
+
+    # Handle died children.
+    $SIG{CHLD} = sub { $self->sig_child_handler(@_) };
+
+    while ($self->{done} == 0) {
+        # Reap died children.
+        $self->reap_children;
+        # Spawn new children.
+        $self->spawn_children;
+
+        foreach my $group (keys %{ $self->process_group }) {
+            my $process_group = $self->process_group->{$group};
+
+            $self->log->debug(
+                scalar keys %{$process_group->{child}},
+                "processes running for process group $group:",
+                keys %{$process_group->{child}},
+            );
+        }
+
+        # Sleep a while
+        Time::HiRes::usleep(500_000);
+    }
+
+    $self->kill_children;
+}
+
+sub run_agent {
+    my ($self, $inputs) = @_;
+
+    if ($inputs) {
+        $self->{inputs} = $inputs;
+    }
+
+    while ($self->{done} == 0) {
+        eval { $self->run_log_shipper };
+
+        if ($self->{done} == 0) {
+            sleep 3;
+        }
+    }
+}
+
+sub run_log_shipper {
+    my $self = shift;
+    my $poll = $self->config->{poll} / 1000;
+    my $inputs = $self->{inputs};
+    my $outputs = $self->{outputs};
+    my $max_lines = $self->config->{lines};
+    my $messurement = Time::HiRes::gettimeofday();
+    my $count_lines = 0;
+    my $count_bytes = 0;
+    my $benchmark = $self->config->{benchmark};
+    my (%failed);
+
+    while ($self->{done} == 0) {
+        # If no lines was received, then the agent should
+        # sleep for a while - low cost cpu :-)
+        my $time = Time::HiRes::gettimeofday() + $poll;
+
+        # otype = output type
+        # itype = input type
+        #
+        # If an event couldn't be send, then all left lines are
+        # stored with the output object to the %failed hash and
+        # the type of the input is used as the hash key.
+        # If the hash %failed is not empty, then all inputs with
+        # no type and all input types that are stored in %failed
+        # will be skipped until %failed is empty. That means that
+        # no events will be read from the inputs.
+        foreach my $input (@$inputs) {
+            # Some data for benchmarks. The count of lines and bytes are printed each second.
+            if ($benchmark) {
+                my $delta = sprintf("%.6f", Time::HiRes::gettimeofday() - $messurement);
+                if ($delta > 1) {
+                    $count_bytes = sprintf("%.3fM", $count_bytes > 0 ? $count_bytes / 1_048_576 : 0);
+                    $self->log->notice("processed $count_lines lines / $count_bytes bytes in $delta seconds");
+                    $messurement = Time::HiRes::gettimeofday();
+                    $count_lines = 0;
+                    $count_bytes = 0;
+                }
+            }
+
+            # Check if it's time to process the input.
+            if ($input->{time} - Time::HiRes::gettimeofday() > 0) {
+                next;
+            }
+
+            # The type of the input. Note that the type can be
+            # overwritten if the input format is a json event.
+            my $itype = $input->{config}->{type};
+            my $ipath = $input->{config}->{path};
+
+            # If there are errors detected and no type is set,
+            # then shipping log data is blocked for inputs
+            # with no type until %failed is empty.
+            if (!defined $itype && scalar keys %failed) {
+                next;
+            }
+
+            # If there exists errors for this type, then the stored
+            # lines must be flushed to the outputs first.
+            if ($failed{$itype}) {
+                $self->log->info("found failed events for input type $itype");
+
+                # Process each failed output until no further outputs exists.
+                while (my $ref = shift @{$failed{$itype}}) {
+                    my $output = $ref->{output};
+                    my $otype  = $ref->{type};
+                    my $count  = 0;
+                    my $bytes  = 0;
+
+                    # Process each line until the array is empty.
+                    $self->log->info("try to process", scalar @{$ref->{lines}}, "events for output type $otype");
+                    while (my $line = shift @{$ref->{lines}}) {
+                        my ($otype, $event) = $self->prepare_message($input->{config}, $line)
+                            or next;
+
+                        # If the output is not available then the last line
+                        # is stored back to the array.
+                        if (!$output->push($event)) {
+                            unshift @{$ref->{lines}}, $line;
+                            last;
+                        }
+
+                        $count += 1;
+                        $bytes += length($line);
+                        $count_lines += 1;
+                        $count_bytes += $bytes;
+                    }
+
+                    if ($count) {
+                        $self->log->notice(
+                            "output $otype is reachable again -",
+                            "flushed $count lines with $bytes bytes"
+                        );
+                    }
+
+                    # If it wasn't possilbe to ship all events then the
+                    # output returns an error. In this case the output
+                    # is stored back to the %failed hash.
+                    if (@{$ref->{lines}}) {
+                        # The error message should only be logged if the output died again.
+                        if ($count) {
+                            $count = scalar @{$ref->{lines}};
+                            $bytes = length join("", @{$ref->{lines}});
+                            $self->log->error(
+                                "output $otype returns an error again -",
+                                "held $count lines with $bytes bytes in stash"
+                            );
+                        }
+                        unshift @{$failed{$itype}}, $ref;
+                        last;
+                    }
+                }
+
+                # If no items left, then the input type can be deleted
+                # and processed again in the next run.
+                if (!@{$failed{$itype}}) {
+                    delete $failed{$itype};
+                }
+
+                # Process the next input.
+                next;
+            }
+
+            # Get events from the input.
+            $self->log->debug("pull lines from input type $itype path $ipath");
+            my $lines = $input->{object}->pull(lines => $max_lines);
+
+            # If no lines exists, just jump to the next input and
+            # process the input at time + poll.
+            if (!$lines || !@$lines) {
+                $input->{time} = Time::HiRes::gettimeofday() + $poll;
+                next;
+            }
+
+            # If the input return events then the global interval
+            # is set to now, so the sleep value should be 0.
+            $time = Time::HiRes::gettimeofday();
+            $self->log->debug("pulled", scalar @$lines, "lines from input type $itype path $ipath");
+
+            # Process each event and store each event by the output type.
+            my (%prepared_events, %lines_by_type);
+            while (my $line = shift @$lines) {
+                my ($otype, $event) = $self->prepare_message($input->{config}, $line)
+                    or next;
+                push @{$prepared_events{$otype}}, $event;
+                push @{$lines_by_type{$otype}}, $line;
+            }
+
+            foreach my $otype (keys %prepared_events) {
+                my $events = $prepared_events{$otype};
+                if (!exists $outputs->{$otype}) {
+                    $self->log->warning("received events from input type $itype with an non existent output type $otype");
+                }
+                foreach my $output (@{$outputs->{$otype}}) {
+                    for (my $i=0; $i <= $#{$events}; $i++) {
+                        if (!$output->push($events->[$i])) {
+                            my $left  = [ @{$lines_by_type{$otype}}[$i..$#{$events}] ];
+                            my $count = $#{$events} - $i;
+                            my $bytes = length join("", @$left);
+                            $self->log->error(
+                                "output $otype returns an error -",
+                                "stashing $count lines with $bytes bytes"
+                            );
+                            push @{$failed{$itype}}, {
+                                type   => $otype,
+                                output => $output,
+                                lines  => $left,
+                            };
+                            last;
+                        } else {
+                            $count_lines += 1;
+                            $count_bytes += length $lines_by_type{$otype}[$i];
+                            $self->log->debug("wrote event $i/$#{$events} to output $otype");
+                        }
+                    }
+                }
+            }
+        }
+
+        $time -= Time::HiRes::gettimeofday();
+
+        if ($time > 0 && $self->{done} == 0) {
+            $self->log->debug(sprintf("sleep for %.6f seconds", $time));
+            Time::HiRes::usleep($time * 1_000_000);
+        }
+    }
+}
+
+sub prepare_message {
+    my ($self, $input, $line) = @_;
+    my ($event, $type, $timestamp);
+
+    $self->log->debug("prepare message for input type $input->{type} path $input->{path}");
+    $self->log->debug("event: $line");
+
+    if ($input->{format} eq "json_event") {
+        eval { $event = $self->json->decode($line) };
+        if ($@) {
+            $self->log->error("unable to decode json event for input $input->{type}:", $@);
+            $self->log->error($line);
+            return ();
+        }
+        $event->{'@type'} ||= $input->{type};
+        push @{$event->{'@tags'}}, @{$input->{tags}};
+        foreach my $field (keys %{$input->{add_field}}) {
+            $event->{$field} = $input->{add_field}->{$field};
+        }
+    } elsif ($input->{format} eq "plain") {
+        $timestamp = POSIX::strftime("%Y-%m-%dT%H:%M:%S%z", localtime(time));
+        $timestamp =~ s/(\d{2})(\d{2})\z/$1:$2/;
+        $event = {
+            '@timestamp'   => $timestamp,
+            '@source'      => "file://" . $self->{hostname} . $input->{path},
+            '@source_host' => $self->{hostname},
+            '@source_path' => $input->{path},
+            '@type'        => $input->{type},
+            '@fields'      => $input->{add_field},
+            '@tags'        => $input->{tags},
+            '@message'     => $line,
+        };
+    };
+
+    if ($input->{__add_field}) {
+        foreach my $code (@{$input->{__add_field_code}}) {
+            &$code($event);
+        }
+    }
+
+    return ($event->{'@type'}, $self->json->encode($event));
+}
+
+sub get_config {
+    my $self = shift;
+
+    my $config = Awesant::Config->parse(
+        $self->{args}->{config}
+    );
+
+    $self->{config} = $self->validate_config($config);
+}
+
+sub write_pidfile {
+    my $self = shift;                                                                                                               
+    open my $fh, ">", $self->{args}->{pidfile}
+        or die "unable to write pid file $self->{args}->{pidfile}: $!";
+    print $fh $$;
+    close $fh;
+}
+
+sub remove_pidfile {
+    my $self = shift;
+
+    if (-f $self->{args}->{pidfile}) {
+        unlink($self->{args}->{pidfile});
+            # "or die" is not necessaray because
+            # awesant stop running
+    }
+}
+
+sub create_logger {
+    my $self = shift;
+
+    $self->{log} = Log::Handler->create_logger("awesant");
+
+    if ($self->config->{logger}) {
+        $self->{log}->config(config => $self->config->{logger});
+    }
+}
+
+sub spawn_children {
+    my $self = shift;
+
+    foreach my $group (keys %{ $self->process_group }) {
+        my $process_group = $self->process_group->{$group};
+        my $current_worker = scalar keys %{$process_group->{child}};
+        my $wanted_worker = $process_group->{workers};
+
+        if ($current_worker < $wanted_worker) {
+            for (1..$wanted_worker - $current_worker) {
+                # Fork a new child.
+                my $pid = fork;
+
+                if ($pid) {
+                    # If $pid is set, then it's the parent.
+                    $self->{child}->{$pid} = $group;
+                    # The pid is stored to the process group just to
+                    # count how many processes are running for the group.
+                    $process_group->{child}->{$pid} = $group;
+                    # Hoa yeah! A new perl machine was born! .-)
+                    $self->log->info("forked child $pid for process group $group");
+                } elsif (!defined $pid) {
+                    # If the $pid is undefined then fork failed.
+                    die "unable to fork - $!";
+                } else {
+                    # If the pid is defined then it's the child.
+                    eval { $self->run_agent($process_group->{inputs}) };
+                    exit($? ? 9 : 0);
+                }
+            }
+        }
+    }
+}
+
+sub reap_children {
+    my $self = shift;
+    my $child = $self->{child};
+    my $reaped = $self->{reaped};
+    my @reaped = keys %$reaped;
+
+    foreach my $pid (@reaped) {
+        my $group = delete $child->{$pid};
+        delete $self->process_group->{$group}->{child}->{$pid};
+        delete $reaped->{$pid};
+    }
+}
+
+sub kill_children {
+    my $self  = shift;
+    my $child = $self->{child};
+    my @chld  = keys %$child;
+
+    # Don't TERM the daemon. At first we reap all children.
+    local $SIG{TERM} = "IGNORE";
+
+    # Give the children 15 seconds time to stop.
+    my $wait = time + 15;
+
+    # Try to kill the agents soft.
+    $self->log->info("send sig term to children", @chld);
+    kill 15, @chld;
+
+    while (@chld && $wait > time) {
+        $self->log->info("wait for children", @chld);
+        sleep 1;
+        $self->reap_children;
+        @chld = keys %$child;
+    }
+
+    # All left children will be killed hard.
+    if (scalar keys %$child) {
+        @chld = keys %$child;
+        $self->log->info("send sig kill to children", @chld);
+        kill 9, @chld;
+    }
+}
+
+sub sig_child_handler {
+    my $self = shift;
+
+    while ((my $child = waitpid(-1, WNOHANG)) > 0) {
+        if ($? > 0) {
+            $self->log->error("child $child died: $?");
+        } else {
+            $self->log->notice("child $child died: $?");
+        }
+
+        # Store the PID to delete the it later from $self->{child}
+        $self->{reaped}->{$child} = $child;
+    }
+
+    $SIG{CHLD} = sub { $self->sig_child_handler(@_) };
+}
+
+sub validate_config {
+    my $self = shift;
+
+    my %options = Params::Validate::validate(@_, {
+        poll => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^(?:[1-9]\d\d\d|[1-9]\d\d)\z/,
+            default => 500,
+        },
+        lines => {
+            type => Params::Validate::SCALAR,
+            default => 100,
+        },
+        output => {
+            type => Params::Validate::HASHREF,
+        },
+        input => {
+            type => Params::Validate::HASHREF,
+        },
+        logger => {
+            type => Params::Validate::HASHREF,
+            optional => 1,
+        },
+        benchmark => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^(?:yes|no|0|1)\z/,
+            default => 0,
+        },
+    });
+
+    if ($options{benchmark} eq "no") {
+        $options{benchmark} = 0;
+    }
+
+    foreach my $key (qw/output input/) {
+        my $ref = $options{$key};
+        foreach my $type (keys %$ref) {
+            if (ref $ref->{$type} eq "HASH") {
+                $ref->{$type} = [ $ref->{$type} ];
+            }
+        }
+    }
+
+    return \%options;
+}
+
+sub validate_agent_config {
+    my $self = shift;
+
+    my %options = Params::Validate::validate(@_, {
+        type => {
+            type => Params::Validate::SCALAR,
+        },
+        tags => {
+            type => Params::Validate::SCALAR
+                    | Params::Validate::ARRAYREF,
+            default => [ ],
+        },
+        format => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^(?:plain|json_event)\z/,  
+            default => "plain",
+        },
+        add_field => {
+            type => Params::Validate::SCALAR
+                    | Params::Validate::HASHREF
+                    | Params::Validate::ARRAYREF,
+            default => { },
+        },
+        __add_field => {
+            type => Params::Validate::HASHREF,
+            optional => 1,
+        },
+        path => {
+            type => Params::Validate::SCALAR,
+            default => "/",
+        },
+        workers => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^\d+\z/,
+            default => 0,
+        },
+    });
+
+    # add_field => {
+    #     domain => {
+    #         key    => '@source_path',
+    #         match  => "([a-z]+\.[a-z]+)/([a-z]+)/[^/]+$",
+    #         concat => "$2.$1",
+    #     }
+    # }
+
+    if (defined $options{add_field}) {
+        if (ref $options{add_field} eq "ARRAY") {
+            $options{add_field} = { @{$options{add_field}} };
+        } elsif (ref $options{add_field} ne "HASH") {
+            my @fields;
+            foreach my $field (split /,/, $options{add_field}) {
+                $field =~ s/^\s+//;
+                $field =~ s/\s+\z//;
+                push @fields, $field;
+            }
+            $options{add_field} = { @fields };
+        }
+    }
+
+    if (defined $options{__add_field}) {
+        foreach my $field (keys %{$options{__add_field}}) {
+            my $ref = $options{__add_field}{$field};
+
+            # The code generation. I'm sorry that it's a bit unreadable.
+            my $func = "sub { my (\$e) = \@_; if (\$e->{'$ref->{field}'} =~ m!$ref->{match}!) { ";
+            $func .= "\$e->{'\@fields'}->{'$field'} = \"$ref->{concat}\"; }";
+            if (defined $ref->{default}) {
+                $func .= " else { \$e->{'\@fields'}->{'$field'} = '$ref->{default}'; } ";
+            }
+            $func .= "}";
+
+            # Eval the code.
+            my $code = eval $func;
+            push @{$options{__add_field_func}}, $func;
+            push @{$options{__add_field_code}}, $code;
+        }
+    }
+
+    if (defined $options{tags} && ref $options{tags} ne "ARRAY") {
+        my $tags = $options{tags};
+        $options{tags} = [ ];
+        foreach my $tag (split /,/, $tags) {
+            $tag =~ s/^\s+//;
+            $tag =~ s/\s+\z//;
+            push @{$options{tags}}, $tag;
+        }
+    }
+
+    return \%options;
+}
+
+sub validate_add_field_match {
+    my $self = shift;
+
+    my %options = Params::Validate::validate(@_, {
+        field => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^\w+\z/,
+        },
+        match => {
+            type => Params::Validate::SCALAR,
+        },
+        concat => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^[^"]+\z/,
+        },
+        default => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^[^']+\z/,
+            optional => 1,
+        },
+    });
+
+    return \%options;
+}
+
+1;
--- /dev/null
+++ awesant-0.7/perl/blib/lib/Awesant/Input/Socket.pm
@@ -0,0 +1,343 @@
+=head1 NAME
+
+Awesant::Input::Socket - Listen on TCP and/or UDP sockets and ship logs for logstash.
+
+=head1 SYNOPSIS
+
+    Awesant::Input::Socket->new(
+        host => "127.0.0.1",
+        port => 12345,
+        proto => "tcp"
+        ssl_ca_file => "/path/to/your.ca",
+        ssl_cert_file => "/path/to/your.crt",
+        ssl_key_file => "/path/to/your.key",
+    );
+
+    # lines = max lines
+    # It may be less.
+    $input->pull(lines => 100);
+
+=head1 DESCRIPTION
+
+Listen on a TCP or UDP socket and ship events.
+
+=head1 OPTIONS
+
+=head2 host
+
+The ip address to listen on.
+
+Default: 127.0.0.1
+
+=head2 port
+
+The port number to listen on.
+
+Default: no default
+
+=head2 auth
+
+With this option it's possible to set a username and password if you want
+that each client have to authorize.
+
+    user:password
+
+See also the documentation of Awesant::Output::Socket.
+
+=head2 proto
+
+The protocol to use. At the moment only tcp is allowed.
+
+Default: tcp
+
+=head2 ssl_ca_file, ssl_cert_file, ssl_key_file
+
+If you want to use ssl connections then you can set the path to your ca, certificate and key file.
+
+This options are equivalent to the options of IO::Socket::SSL.
+
+See cpan http://search.cpan.org/~sullr/IO-Socket-SSL/.
+
+Default: no default
+
+=head2 response
+
+Send a response for each received event.
+
+    response => "ok"
+
+Then the string "ok" is send back to the sender.
+
+See also the documentation of Awesant::Output::Socket.
+
+=head1 METHODS
+
+=head2 new
+
+Create a new input object.
+
+=head2 pull(lines => $number)
+
+This method tries to read the given number of lines of each client connection.
+
+It may be less lines.
+
+=head2 open_socket
+
+Open the listen sockets for TCP and UDP.
+
+=head2 close_socket
+
+Close the socket.
+
+=head2 select
+
+Just an accessor to the selector object.
+
+=head2 socket
+
+Just an accessor to the socket object.
+
+=head2 config
+
+Just an accessor to the config object.
+
+=head2 log
+
+Just an accessor to the logger object.
+
+=head2 validate
+
+Validate the configuration.
+
+=head1 PREREQUISITES
+
+    Log::Handler
+    Params::Validate
+    IO::Socket::INET
+    IO::Select
+
+For SSL only:
+
+    IO::Socket::SSL
+
+=head1 EXPORTS
+
+No exports.
+
+=head1 REPORT BUGS
+
+Please report all bugs to <support(at)bloonix.de>.
+
+=head1 AUTHOR
+
+Jonny Schulz <support(at)bloonix.de>.
+
+=head1 COPYRIGHT
+
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
+
+=cut
+
+package Awesant::Input::Socket;
+
+use strict;
+use warnings;
+use IO::Socket::INET;
+use IO::Select;
+use Params::Validate qw();
+use Log::Handler;
+use base qw(Class::Accessor::Fast);
+
+__PACKAGE__->mk_accessors(qw/log socket select/);
+
+sub new {
+    my $class = shift;
+    my $opts  = $class->validate(@_);
+    my $self  = bless $opts, $class;
+
+    $self->{log} = Log::Handler->get_logger("awesant");
+    $self->open_socket;
+    $self->log->info("$class initialized");
+
+    return $self;
+}
+
+sub open_socket {
+    my $self = shift;
+    my $host = $self->{host};
+    my $port = $self->{port};
+    my $proto = $self->{proto};
+    my $sockmod = $self->{sockmod};
+    my $sockopts = $self->{sockopts};
+
+    $self->{socket} = $sockmod->new(%$sockopts)
+        or die "unable to create socket for $proto:$host:$port - $!";
+
+    $self->{select} = IO::Select->new($self->{socket});
+}
+
+sub pull {
+    my ($self, %opts) = @_;
+    my $response = $self->{response};
+    my $count = $opts{lines} || 1;
+    my @lines = ();
+
+    my @ready = $self->select->can_read;
+
+    foreach my $fh (@ready) {
+        if ($fh == $self->socket) {
+            $self->socket->timeout(10);
+            my $client = $self->socket->accept;
+
+            if ($! == &Errno::ETIMEDOUT) {
+                $self->log->warning("accept runs on a timeout");
+            }
+
+            $self->socket->timeout(0);
+            next unless $client;
+            my $addr = $client->peerhost || "n/a";
+
+            if ($self->{auth}) {
+                eval {
+                    local $SIG{__DIE__} = sub { alarm(0) };
+                    local $SIG{ALRM} = sub { die "timeout" };
+                    alarm(5);
+                    my $authstr = <$client>;
+                    chomp $authstr;
+                    if ($authstr ne $self->{auth}) {
+                        print $client "0\n";
+                        die "noauth";
+                    }
+                    print $client "1\n";
+                    alarm(0);
+                };
+                if ($@) {
+                    my $err = $@;
+                    if ($err =~ /^timeout/) {
+                        $self->log->warning("timed out connection from $addr as waited for auth string");
+                    } else {
+                        $self->log->warning("unauthorized connection from $addr");
+                    }
+                } else {
+                    $self->select->add($client);
+                }
+            } else {
+                $self->select->add($client);
+            }
+
+            next;
+        }
+
+        my $request = <$fh>;
+
+        if (!defined $request) {
+            $self->log->debug("remove closed socket of", $fh->peerhost | "n/a");
+            $self->select->remove($fh);
+            close $fh;
+            next;
+        }
+
+        if (defined $response) {
+            print $fh "$response\n";
+        }
+
+        chomp($request);
+        push @lines, $request;
+        $count--;
+        last unless $count;
+    }
+
+    return \@lines;
+}
+
+sub close_socket {
+    my $self = shift;
+    $self->DESTROY;
+}
+
+sub validate {
+    my $class = shift;
+
+    my %options = Params::Validate::validate(@_, {
+        host => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^[\d\.a-f:]+\z/,
+        },
+        port => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^\d+\z/,
+        },
+        auth => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+        response => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+        proto => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^(?:tcp|udp)\z/,
+            default => "tcp",
+        },
+        ssl_ca_file => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+        ssl_cert_file => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+        ssl_key_file => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+    });
+
+    if ($options{ssl_cert_file} && $options{ssl_key_file}) {
+        require IO::Socket::SSL;
+        $options{sockmod} = "IO::Socket::SSL";
+    } elsif ($options{ssl_cert_file} || $options{ssl_key_file}) {
+        die "parameter ssl_cert_file and ssl_key_file are both mandatory for ssl sockets";
+    }
+
+    if (!$options{sockmod}) {
+        $options{sockmod} = "IO::Socket::INET";
+    }
+
+    if ($options{sockmod} eq "IO::Socket::SSL" && $options{proto} eq "udp") {
+        die "the udp protocol is not available in conjunction with ssl";
+    }
+
+    my %sockopts = (
+        host  => "LocalAddr",
+        port  => "LocalPort",
+        proto => "Proto",
+        ssl_ca_file   => "SSL_ca_file",
+        ssl_cert_file => "SSL_cert_file",
+        ssl_key_file  => "SSL_key_file",
+    );
+
+    while (my ($opt, $modopt) = each %sockopts) {
+        if ($options{$opt}) {
+            $options{sockopts}{$modopt} = $options{$opt};
+        }
+    }
+
+    $options{sockopts}{Listen} = SOMAXCONN;
+    $options{sockopts}{Reuse}  = 1;
+
+    return \%options;
+}
+
+sub DESTROY {
+    my $self = shift;
+    my $socket = $self->{socket};
+
+    if ($socket) {
+        close $socket;
+    }
+}
+
+1;
--- /dev/null
+++ awesant-0.7/perl/blib/lib/Awesant/Input/File.pm
@@ -0,0 +1,317 @@
+=head1 NAME
+
+Awesant::Input::File - Files as input.
+
+=head1 SYNOPSIS
+
+    # Create a new tail-like object.
+    my $input = Awesant::Input::File->new(
+        path => "/var/log/messages",
+        save_position => "yes", # experimental
+    );
+
+    # Pull the next 100 lines that was appended
+    # to the log file.
+    $input->pull(lines => 100);
+
+=head1 DESCRIPTION
+
+Log files as input. Log file rotation is supported, but note that
+you should configure delayed compression for log files.
+
+=head1 OPTIONS
+
+=head2 path
+
+The path to the log file.
+
+=head2 save_position
+
+Experimental feature.
+
+If the option save_position is set to true then the last position
+with the inode of the log file is saved to a file. If Awesant is down
+then it can resume its work where it was stopped. This is useful if you
+want to lose as less data as possible of your log files.
+
+Please note that this feature is experimental and does not keep log file
+rotations.
+
+=head1 METHODS
+
+=head2 new
+
+Create a new input object.
+
+=head2 get_lastpos
+
+Get the last position if the option C<save_position> is true.
+
+=head2 open_logfile
+
+Open the log file and store the inode for later checks.
+
+=head2 check_logfile
+
+This method just checks if the inode has changed of the currently opened
+file and the file that is found on the file system. If logrotate moved
+the file, then the inode changed. In this case the rotated file is read
+until its end and then the file will be closed to re-open the new file
+on the file system.
+
+=head2 pull(lines => $number)
+
+This methods reads the excepted number of lines or until the end of the
+file and returns the lines as a array reference.
+
+=head2 validate
+
+Validate the configuration that is passed to the C<new> constructor.
+
+=head2 log
+
+Just a accessor to the logger.
+
+=head1 PREREQUISITES
+
+    Fcntl
+    Params::Validate
+    Log::Handler
+
+=head1 EXPORTS
+
+No exports.
+
+=head1 REPORT BUGS
+
+Please report all bugs to <support(at)bloonix.de>.
+
+=head1 AUTHOR
+
+Jonny Schulz <support(at)bloonix.de>.
+
+=head1 COPYRIGHT
+
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
+
+=cut
+
+
+package Awesant::Input::File;
+
+use strict;
+use warnings;
+use Fcntl qw( :flock O_WRONLY O_CREAT O_RDONLY );
+use Params::Validate qw();
+use Log::Handler;
+
+sub new {
+    my $class = shift;
+    my $opts = $class->validate(@_);
+    my $self = bless $opts, $class;
+
+    $self->{log} = Log::Handler->get_logger("awesant");
+    $self->{reached_end_of_file} = 0;
+    $self->get_lastpos;
+    $self->open_logfile;
+    $self->log->info("$class initialized");
+
+    return $self;
+}
+
+sub get_lastpos {
+    my $self = shift;
+    my $file = $self->{path};
+    my $libdir = $self->{libdir};
+    my $inode = "";
+
+    $self->{lastpos} = -e $file ? (stat($file))[7] : 0;
+
+    if (!$self->{save_position}) {
+        return;
+    }
+
+    my $basename = do { $self->{path} =~ m!([^\\/]+)\z!; $1 };
+    my $posfile = "$libdir/awesant-$basename.pos";
+
+    if (-e $posfile) {
+        $self->log->debug("read last position from $posfile");
+        open my $fh, "<", $posfile or die "unable to open '$posfile' for reading - $!";
+        my $line = <$fh>;
+        my ($inode, $lastpos) = split /:/, $line;
+
+        if (defined $inode && defined $lastpos && $inode =~ /^\d+\z/ && $lastpos =~ /^\d+\z/) {
+            $inode =~ s/^0+//;
+            $lastpos =~ s/^0+//;
+
+            if (-e $file && (stat($file))[1] eq $inode) {
+                $self->{lastpos} = $lastpos;
+            }
+        }
+
+        close $fh;
+    }
+
+    $self->log->debug("last position $self->{lastpos}");
+    $self->log->debug("open '$posfile' for writing");
+    sysopen my $fhpos, $posfile, O_CREAT | O_WRONLY
+        or die "unable to open '$posfile' for writing - $!";
+
+    # autoflush
+    my $oldfh = select $fhpos;
+    $| = $self->{autoflush};
+    select $oldfh;
+
+    # save the file handle for later usage
+    $self->{fhpos} = $fhpos;
+}
+
+sub open_logfile {
+    my $self = shift;
+    my $file = $self->{path};
+    my $fhlog = $self->{fhlog};
+
+    if ($fhlog && $self->check_logfile) {
+        return $fhlog;
+    }
+
+    $self->log->info("open '$file' for reading");
+
+    open $fhlog, "<", $file or do {
+        $self->log->error("unable to open logfile '$file' for reading - $!");
+        return undef;
+    };
+
+    # Store the inode for the logfile to check
+    # later if the inode changed because logrotate
+    # moves the file.
+    $self->{inode} = (stat($file))[1];
+    $self->log->debug("stored inode $self->{inode} for file '$file'");
+
+    # If fhlog is already set then we just reopen the next
+    # file and jump to the start of the file, otherwise
+    # a log file wasn't opened before and we jump to the
+    # position of get_lastpos
+    if ($self->{fhlog}) {
+        $self->{lastpos} = 0;
+    }
+
+    $self->log->info("seek to position $self->{lastpos} of file '$file'");
+    seek($fhlog, $self->{lastpos}, 0);
+    $self->{fhlog} = $fhlog;
+    return $fhlog;
+}
+
+sub check_logfile {
+    my $self  = shift;
+    my $file  = $self->{path};
+    my $inode = $self->{inode};
+    my $fhlog = $self->{fhlog};
+
+    # If the logfile is rotated but not finished then the logfile
+    # shouldn't be closed, otherwise we will miss some lines...
+    if ($self->{reached_end_of_file} == 0) {
+        #$self->log->debug("skip check logfile - reached_end_of_file=$self->{reached_end_of_file}");
+        return 1;
+    }
+
+    # Clean up the eof marker
+    $self->{reached_end_of_file} = 0;
+
+    # Check if the logfile exists.
+    if (!-e $file) {
+        $self->log->info("the log file '$file' does not exists any more");
+        close $fhlog;
+        $self->{fhlog} = undef;
+        return 0;
+    }
+
+    # Check if the inode has changed, because it's possible
+    # that logrotate.d rotates the log file.
+    if ($inode != (stat($file))[1]) {
+        $self->log->info("inode of file '$file' changed - closing file handle");
+        $self->{fhlog} = undef;
+        close $fhlog;
+        return 0;
+    }
+
+    # Check if the the current position where the log file was
+    # read is higher than the file size. It's possible that
+    # the logfile was flushed.
+    if ((stat($file))[7] < $self->{lastpos}) {
+        $self->log->info("the size of file '$file' shrinks - seeking back");
+        seek($fhlog, 0, 0);
+        $self->{lastpos} = 0;
+    } 
+
+    return 1;
+}
+
+sub pull {
+    my ($self, %opts) = @_;
+
+    local $SIG{PIPE} = "IGNORE";
+
+    my $max_lines = $opts{lines} || 1;
+    my $lines = [ ];
+    my $fhpos = $self->{fhpos};
+    my $fhlog = $self->open_logfile
+        or return $lines;
+
+    while (my $line = <$fhlog>) {
+        chomp $line;
+        push @$lines, $line;
+        #$self->log->debug("read", length($line), "bytes from file");
+        last unless --$max_lines;
+    }
+
+    # Store the last position
+    $self->{lastpos} = tell($fhlog);
+
+    if ($self->{fhpos}) {
+        seek($fhpos, 0, 0);
+        printf $fhpos "%014d:%014d", $self->{inode}, $self->{lastpos};
+    }
+
+    # If EOF is reached then the logfile should be
+    # checked if the file was rotated.
+    if ($max_lines > 0) {
+        $self->log->debug("reached end of file");
+        $self->{reached_end_of_file} = 1;
+    }
+
+    return $lines;
+}
+
+sub validate {
+    my $self = shift;
+
+    my %options = Params::Validate::validate(@_, {
+        libdir => {
+            type => Params::Validate::SCALAR,
+            default => "/var/lib/awesant",
+        },
+        save_position => {
+            type => Params::Validate::SCALAR,
+            default => 0,
+            regex => qr/^(?:yes|no|1|0)\z/,
+        },
+        path => {
+            type => Params::Validate::SCALAR,
+        },
+    });
+
+    if ($options{save_position} eq "no") {
+        $options{save_position} = 0;
+    }
+
+    return \%options;
+}
+
+sub log {
+    my $self = shift;
+
+    return $self->{log};
+}
+
+1;
--- /dev/null
+++ awesant-0.7/perl/blib/lib/Awesant/Output/Redis.pm
@@ -0,0 +1,317 @@
+=head1 NAME
+
+Awesant::Output::Redis - Send messages to a Redis database.
+
+=head1 SYNOPSIS
+
+    my $output = Awesant::Output::Redis->new(
+        host => "127.0.0.1",
+        port => 6379,
+        timeout => 20,
+        database => 0,
+        password => "secret",
+    );
+
+    $output->push($line);
+
+=head1 DESCRIPTION
+
+This transport module connects to a Redis database and ships data via LPUSH.
+
+=head1 OPTIONS
+
+=head2 host
+
+The hostname or ip address of the Redis server.
+
+Default: 127.0.0.1
+
+=head2 port
+
+The port number where the Redis server is listen on.
+
+Default: 6379
+
+=head2 timeout
+
+The timeout in seconds to connect and transport data to the Redis server.
+
+Default: 10
+
+=head2 database
+
+The database to select.
+
+Default: 0
+
+=head2 password
+
+The password to use for authentication.
+
+Default: not set
+
+=head2 key 
+
+The key is mandatory and is used to transport the data. This key is necessary for logstash to pull the data from the Redis database.
+
+Default: not set
+
+=head1 METHODS
+
+=head2 new
+
+Create a new output object.
+
+=head2 connect
+
+Connect to the redis database.
+
+=head2 push
+
+Push data to redis via LPUSH command.
+
+=head2 validate
+
+Validate the configuration that is passed to the C<new> constructor.
+
+=head2 log
+
+Just a accessor to the logger.
+
+=head1 PREREQUISITES
+
+    IO::Socket::INET
+    Log::Handler
+    Params::Validate
+
+=head1 EXPORTS
+
+No exports.
+
+=head1 REPORT BUGS
+
+Please report all bugs to <support(at)bloonix.de>.
+
+=head1 AUTHOR
+
+Jonny Schulz <support(at)bloonix.de>.
+
+=head1 COPYRIGHT
+
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
+
+=cut
+
+package Awesant::Output::Redis;
+
+use strict;
+use warnings;
+use IO::Socket::INET;
+use Log::Handler;
+use Params::Validate qw();
+
+sub new {
+    my $class = shift;
+    my $opts = $class->validate(@_);
+    my $self = bless $opts, $class;
+
+    $self->{select_database} = join("\r\n",
+        '*2', # SELECT + db
+        '$6',
+        'SELECT',
+        '$' . length($self->{database}),
+        $self->{database} . "\r\n"
+    );
+
+    if ($self->{password}) {
+        $self->{auth_client} = join("\r\n",
+            '*2', # AUTH + password
+            '$4',
+            'AUTH',
+            '$' . length($self->{password}),
+            $self->{password} . "\r\n"
+        );
+    }
+
+    $self->{log} = Log::Handler->get_logger("awesant");
+
+    $self->{__alarm_sub} = sub {
+        alarm(0);
+    };
+
+    $self->{__timeout_sub} = sub {
+        die join(" ",
+            "connection to redis database",
+            "$self->{host}:$self->{port}",
+            "timed out after $self->{timeout} seconds",
+        );
+    };
+
+    $self->log->notice("$class initialized");
+    return $self;
+}
+
+sub connect {
+    my $self = shift;
+
+    if ($self->{sock}) {
+        return $self->{sock};
+    }
+
+    $self->log->notice("connect to redis server $self->{host}:$self->{port}");
+
+    $self->{sock} = IO::Socket::INET->new(
+        PeerAddr => $self->{host},
+        PeerPort => $self->{port},
+        Proto    => "tcp",
+    );
+
+    if (!$self->{sock}) {
+        $self->log->error("unable to connect to redis server $self->{host}:$self->{port} - $!");
+        return undef;
+    }
+
+    $self->{sock}->autoflush(1);
+
+    $self->log->notice("connected to redis server $self->{host}:$self->{port}");
+
+    if ($self->{password}) {
+        $self->log->notice("send auth to redis server $self->{host}:$self->{port}");
+
+        $self->_send($self->{auth_client})
+            or die "unable to auth at redis database";
+    }
+
+    $self->log->notice(
+        "select database $self->{database} on",
+        "redis server $self->{host}:$self->{port}"
+    );
+
+    $self->_send($self->{select_database})
+        or die "unable to select redis database";
+
+    $self->log->notice(
+        "successfully selected database $self->{database}",
+        "on redis server $self->{host}:$self->{port}",
+    );
+
+    return $self->{sock};
+}
+
+sub push {
+    my ($self, $line) = @_;
+    my $ret = 0;
+
+    $line = join("\r\n",
+        '*3', # LPUSH + key + line
+        '$5',
+        'LPUSH',
+        '$' . length $self->{key},
+        $self->{key},
+        '$' . length $line,
+        $line . "\r\n"
+    );
+
+    $ret = $self->_send($line);
+
+    return $ret;
+}
+
+sub validate {
+    my $self = shift;
+
+    my %options = Params::Validate::validate(@_, {
+        host => {
+            type => Params::Validate::SCALAR,
+            default => "127.0.0.1",
+        },
+        port => {
+            type => Params::Validate::SCALAR,  
+            default => 6379,
+        },
+        timeout => {  
+            type => Params::Validate::SCALAR,  
+            default => 10,
+        },
+        database => {  
+            type => Params::Validate::SCALAR,  
+            default => 0,
+        },
+        password => {  
+            type => Params::Validate::SCALAR,  
+            optional => 1,
+        },
+        key => {
+            type => Params::Validate::SCALAR,
+        },
+    });
+
+    return \%options;
+}
+
+sub log {
+    my $self = shift;
+
+    return $self->{log};
+}
+
+sub _send {
+    my ($self, $data) = @_;
+
+    my $timeout  = $self->{timeout};
+    my $response = "";
+
+    eval {
+        local $SIG{ALRM} = $self->{__timeout_sub};
+        local $SIG{__DIE__} = $self->{__alarm_sub};
+        alarm($timeout);
+
+        my $sock = $self->connect
+            or die "unable to connect to redis server $self->{host}:$self->{port}";
+
+        my $rest = length($data);
+        my $offset = 0;
+
+        if ($self->log->is_debug) {
+            $self->log->debug("send to redis server $self->{host}:$self->{port}: $data");
+        }
+
+        while ($rest) {
+            my $written = syswrite $sock, $data, $rest, $offset;
+
+            if (!defined $written) {
+                die "system write error: $!\n";
+            }
+
+            $rest -= $written;
+            $offset += $written;
+        }
+
+        $response = <$sock>;
+        alarm(0);
+    };
+
+    if (!$@ && defined $response && $response =~ /^(:\d+|\+OK)/) {
+        return 1;
+    }
+
+    if ($@) {
+        $self->log->error($@);
+    } elsif (!defined $response) {
+        $self->log->error("no response received from redis server $self->{host}:$self->{port}");
+    } elsif ($response =~ /^\-ERR/) {
+        $self->log->error("redis server returns an error: $response");
+    } else {
+        $self->log->error("unknown response from redis server: $response");
+    }
+
+    # Reset the complete connection.
+    if ($self->{sock}) {
+        close($self->{sock});
+        $self->{sock} = undef;
+    }
+
+    return undef;
+}
+
+1;
--- /dev/null
+++ awesant-0.7/perl/blib/lib/Awesant/Output/Screen.pm
@@ -0,0 +1,126 @@
+=head1 NAME
+
+Awesant::Output::Screen - Send messages to the screen.
+
+=head1 SYNOPSIS
+
+    my $log = Awesant::Format::Screen->new(
+        send_to => "stdout"
+    );
+
+=head1 DESCRIPTION
+
+=head1 OPTIONS
+
+=head2 send_to
+
+Where to send the output.
+
+Possible:
+
+    stderr
+    stdout
+    null (means /dev/null)
+
+Default: null
+
+=head1 METHODS
+
+=head2 new
+
+Create a new input object.
+
+=head2 push
+
+Push data to STDOUT, STDERR or to C</dev/null>.
+
+=head2 validate
+
+Validate the configuration that is passed to the C<new> constructor.
+
+=head2 log
+
+Just a accessor to the logger.
+
+=head1 PREREQUISITES
+
+    Log::Handler
+    Params::Validate
+
+=head1 EXPORTS
+
+No exports.
+
+=head1 REPORT BUGS
+
+Please report all bugs to <support(at)bloonix.de>.
+
+=head1 AUTHOR
+
+Jonny Schulz <support(at)bloonix.de>.
+
+=head1 COPYRIGHT
+
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
+
+=cut
+
+package Awesant::Output::Screen;
+
+use strict;
+use warnings;
+use Log::Handler;
+use Params::Validate qw();
+
+sub new {
+    my $class = shift;
+    my $opts = @_ > 1 ? {@_} : shift;
+    my $self = bless $opts, $class;
+
+    if ($self->{send_to} eq "stderr") {
+        $self->{fh} = \*STDERR;
+    } elsif ($self->{send_to} eq "stdout") {
+        $self->{fh} = \*STDOUT;
+    } else {
+        open my $fh, ">>", "/dev/null";
+        $self->{fh} = $fh;
+    }
+
+    $self->{log} = Log::Handler->get_logger("awesant");
+    $self->log->notice("$class initialized");
+
+    return $self;
+}
+
+sub push {
+    my ($self, $line) = @_;
+    my $fh = $self->{fh};
+
+    if ($self->log->is_debug) {
+        $self->log->debug("screen output: $line");
+    }
+
+    print $fh "$line\n";
+}
+
+sub validate {
+    my $self = shift;
+
+    my %options = Params::Validate::validate(@_, {
+        send_to => {
+            type => Params::Validate::SCALAR,
+            default => "null",
+            regex => qr/^(?:stdout|stderr|null)\z/,
+        },
+    });
+
+    return \%options;
+}
+
+sub log {
+    my $self = shift;
+
+    return $self->{log};
+}
+
+1;
--- /dev/null
+++ awesant-0.7/perl/blib/lib/Awesant/Output/Socket.pm
@@ -0,0 +1,437 @@
+=head1 NAME
+
+Awesant::Output::Socket - Send messages to a tcp socket.
+
+=head1 SYNOPSIS
+
+    my $output = Awesant::Output::Socket->new(
+        host => "127.0.0.1",
+        port => 4711,
+        timeout => 10,
+    );
+
+    $output->push($line);
+
+=head1 DESCRIPTION
+
+This transport module connects to a tcp socket and ships data plain or via ssl.
+
+=head1 OPTIONS
+
+=head2 host
+
+The hostname or ip address of the tcp server.
+
+It's possible to set a comma separated list of failover hosts.
+
+    socket {
+        host active-server, failover-server-1, failover-server-2
+        port 4711
+    }
+
+If the connection to one host failed then a connection to the next server is established.
+
+Default: 127.0.0.1
+
+=head2 port
+
+The port number where the tcp server is listen on.
+
+Default: no default
+
+=head2 auth
+
+With this option it's possible to set a username and password, if you want to
+authorize the connection to the host.
+
+    user:password
+
+See also the documentation of Awesant::Input::Socket.
+
+=head2 timeout
+
+The timeout in seconds to transport data to the tcp server.
+
+Default: 10
+
+=head2 connect_timeout
+
+The timeout in seconds to connect to the tcp server.
+
+Default: 10
+
+=head2 proto
+
+The protocol to use. At the moment only tcp is allowed.
+
+Default: tcp
+
+=head2 response
+
+If a response is excepted then you can set the excepted message here as a perl regular expression.
+
+If the regular expression matched, then the transport of the message was successful.
+
+Example:
+
+    response ^(ok|yes|accept)$
+
+Default: no default
+
+See also the documentation of Awesant::Input::Socket.
+
+=head2 persistent
+
+Use persistent connections or not.
+
+Default: yes
+
+=head2 ssl_ca_file, ssl_cert_file, ssl_key_file
+
+If you want to use ssl connections to the server you can set the path to your ca, certificate and key file.
+
+This options are equivalent to the options of IO::Socket::SSL.
+
+See cpan http://search.cpan.org/~sullr/IO-Socket-SSL/.
+
+Default: no default
+
+=head1 METHODS
+
+=head2 new
+
+Create a new output object.
+
+=head2 connect
+
+Connect to the tcp server.
+
+=head2 disconnect
+
+Disconnect from the socket.
+
+=head2 push
+
+Push data to the tcp server.
+
+=head2 validate
+
+Validate the configuration that is passed to the C<new> constructor.
+
+=head2 log
+
+Just a accessor to the logger.
+
+=head1 PREREQUISITES
+
+    IO::Socket::INET
+    Log::Handler
+    Params::Validate
+
+=head1 EXPORTS
+
+No exports.
+
+=head1 REPORT BUGS
+
+Please report all bugs to <support(at)bloonix.de>.
+
+=head1 AUTHOR
+
+Jonny Schulz <support(at)bloonix.de>.
+
+=head1 COPYRIGHT
+
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
+
+=cut
+
+package Awesant::Output::Socket;
+
+use strict;
+use warnings;
+use IO::Socket::INET;
+use Log::Handler;
+use Params::Validate qw();
+
+sub new {
+    my $class = shift;
+    my $opts = $class->validate(@_);
+    my $self = bless $opts, $class;
+
+    $self->{log} = Log::Handler->get_logger("awesant");
+
+    $self->{__alarm_sub} = sub {
+        alarm(0);
+    };
+
+    $self->{__timeout_sub} = sub {
+        die "connection timed out";
+    };
+
+    $self->log->notice("$class initialized");
+
+    return $self;
+}
+
+sub connect {
+    my $self = shift;
+
+    # If the socket is still active, then just return true.
+    # This works only if the sock is set to undef on errors.
+    if ($self->{sock} && $self->{persistent}) {
+        return 1;
+    }
+
+    my $module = $self->{sockmod};
+    my $port   = $self->{port};
+    my $hosts  = $self->{hosts};
+    my @order  = @$hosts;
+    my $sock;
+
+    # Try to connect to the hosts in the configured order.
+    while (my $host = shift @order) {
+        # Although the connection was successful, the host is pushed
+        # at the end of the array. If the connection lost later, then
+        # the next host will be connected.
+        push @$hosts, shift @$hosts;
+
+        # Set the currently used host to the object.
+        $self->{host} = $host;
+
+        # Set the PeerAddr to the host that we a try to connect.
+        $self->{sockopts}->{PeerAddr} = $host;
+
+        # We don't want that the daemon dies if the connection
+        # was not successful. The eval block is also great to
+        # break out on errors.
+        $self->log->notice("connect to server $host:$port");
+        eval {
+            local $SIG{ALRM} = $self->{__timeout_sub};
+            local $SIG{__DIE__} = $self->{__alarm_sub};
+            alarm($self->{connect_timeout});
+            $sock = $module->new(%{$self->{sockopts}});
+            die $! unless $sock;
+            if ($self->{auth}) {
+                print $sock $self->{auth}, "\n";
+                my $ok = <$sock>;
+                chomp($ok);
+                if (!$ok) {
+                    die "not authorized to connect to server";
+                }
+            }
+            alarm(0);
+        };
+
+        # If no error message exists and the socket is created,
+        # then the connection was successful. In this case we
+        # just jump out of the loop.
+        if (!$@ && $sock) {
+            last;
+        }
+
+        # At this point the connection was not successful.
+        if ($@) {
+            $self->log->error($@);
+        }
+
+        $self->log->error("unable to connect to server $host:$port");
+    }
+
+    # It's possible that no connection could be established to any host.
+    # If a connection could be established, then the socket will be
+    # stored to $self->{sock} and autoflush flag is set to the socket.
+    if ($sock) {
+        $sock->autoflush(1);
+        $self->log->notice("connected to server $self->{host}:$self->{port}");
+        $self->{sock} = $sock;
+        return 1;
+    }
+
+    return undef;
+}
+
+sub disconnect {
+    my $self = shift;
+    my $socket = $self->{sock};
+
+    if ($socket) {
+        close $socket;
+    }
+}
+
+sub push {
+    my ($self, $data) = @_;
+
+    # At a newline to the end of the data.
+    $data = "$data\n";
+
+    # At first try to connect to the server.
+    # If the connect was successful, the socket
+    # is stored in $self->{sock}.
+    $self->connect
+        or return undef;
+
+    my $sock = $self->{sock};
+    my $timeout = $self->{timeout};
+    my $response = "";
+
+    eval {
+        local $SIG{ALRM} = $self->{__timeout_sub};
+        local $SIG{__DIE__} = $self->{__alarm_sub};
+        alarm($timeout);
+
+        my $rest = length($data);
+        my $offset = 0;
+
+        if ($self->log->is_debug) {
+            $self->log->debug("set timeout to $timeout seconds");
+            $self->log->debug("send data to server $self->{host}:$self->{port}: $data");
+        }
+
+        while ($rest) {
+            my $written = syswrite $sock, $data, $rest, $offset;
+
+            if (!defined $written) {
+                die "system write error: $!\n";
+            }
+
+            $rest -= $written;
+            $offset += $written;
+        }
+
+        if ($self->log->is_debug) {
+            $self->log->debug("data written to server $self->{host}:$self->{port}");
+        }
+
+        if (defined $self->{response}) {
+            $self->log->debug("read response from server $self->{host}:$self->{port}");
+            $response = <$sock>;
+            $self->log->debug("got response from server $self->{host}:$self->{port}: $response");
+        }
+
+        alarm(0);
+    };
+
+    if (!$self->{persistent}) {
+        $self->close_socket;
+    }
+
+    if ($@) {
+        $self->log->error($@);
+        $self->{sock} = undef;
+        return undef;
+    }
+
+    if (!defined $self->{response}) {
+        return 1;
+    }
+
+    if (!defined $response) {
+        $self->log->error("no response received from server $self->{host}:$self->{port}");
+        $self->{sock} = undef;
+        return undef;
+    }
+
+    if ($response =~ /$self->{response}/) {
+        return 1;
+    }
+
+    $self->log->error("unknown response from server: $response");
+    $self->{sock} = undef;
+    return undef;
+}
+
+sub validate {
+    my $self = shift;
+
+    my %options = Params::Validate::validate(@_, {
+        host => {
+            type => Params::Validate::SCALAR | Params::Validate::ARRAYREF,
+            default => "127.0.0.1",
+        },
+        port => {
+            type => Params::Validate::SCALAR,  
+            default => 6379,
+        },
+        connect_timeout => {
+            type => Params::Validate::SCALAR,
+            default => 10,
+        },
+        timeout => {  
+            type => Params::Validate::SCALAR,  
+            default => 10,
+        },
+        proto => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^tcp\z/,
+            default => "tcp",
+        },
+        auth => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+        response => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+        persistent => {
+            type => Params::Validate::SCALAR,
+            regex => qr/^(?:yes|no|0|1)\z/,
+            default => "yes",
+        },
+        ssl_ca_file => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+        ssl_cert_file => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+        ssl_key_file => {
+            type => Params::Validate::SCALAR,
+            optional => 1,
+        },
+    });
+
+    if ($options{persistent} eq "no") {
+        $options{persistent} = 0;
+    }
+
+    if ($options{ssl_cert_file} && $options{ssl_key_file}) {
+        require IO::Socket::SSL;
+        $options{sockmod} = "IO::Socket::SSL";
+    } elsif ($options{ssl_cert_file} || $options{ssl_key_file}) {
+        die "parameter ssl_cert_file and ssl_key_file are both mandatory for ssl sockets";
+    }
+
+    if (!$options{sockmod}) {
+        $options{sockmod} = "IO::Socket::INET";
+    }
+
+    my %sockopts = (
+        port => 'PeerPort',
+        ssl_ca_file   => 'SSL_ca_file',
+        ssl_cert_file => 'SSL_cert_file',
+        ssl_key_file  => 'SSL_key_file',
+    );
+
+    while (my ($opt, $modopt) = each %sockopts) {
+        if ($options{$opt}) {
+            $options{sockopts}{$modopt} = $options{$opt};
+        }
+    }
+
+    $options{host} =~ s/\s//g;
+    $options{hosts} = [ split /,/, $options{host} ];
+
+    return \%options;
+}
+
+sub log {
+    my $self = shift;
+
+    return $self->{log};
+}
+
+1;
--- /dev/null
+++ awesant-0.7/perl/blib/libdoc/Awesant::Input::File.3pm
@@ -0,0 +1,214 @@
+.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "Awesant::Input::File 3pm"
+.TH Awesant::Input::File 3pm "2013-02-03" "perl v5.10.1" "User Contributed Perl Documentation"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+Awesant::Input::File \- Files as input.
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+.Vb 5
+\&    # Create a new tail\-like object.
+\&    my $input = Awesant::Input::File\->new(
+\&        path => "/var/log/messages",
+\&        save_position => "yes", # experimental
+\&    );
+\&
+\&    # Pull the next 100 lines that was appended
+\&    # to the log file.
+\&    $input\->pull(lines => 100);
+.Ve
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+Log files as input. Log file rotation is supported, but note that
+you should configure delayed compression for log files.
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+.SS "path"
+.IX Subsection "path"
+The path to the log file.
+.SS "save_position"
+.IX Subsection "save_position"
+Experimental feature.
+.PP
+If the option save_position is set to true then the last position
+with the inode of the log file is saved to a file. If Awesant is down
+then it can resume its work where it was stopped. This is useful if you
+want to lose as less data as possible of your log files.
+.PP
+Please note that this feature is experimental and does not keep log file
+rotations.
+.SH "METHODS"
+.IX Header "METHODS"
+.SS "new"
+.IX Subsection "new"
+Create a new input object.
+.SS "get_lastpos"
+.IX Subsection "get_lastpos"
+Get the last position if the option \f(CW\*(C`save_position\*(C'\fR is true.
+.SS "open_logfile"
+.IX Subsection "open_logfile"
+Open the log file and store the inode for later checks.
+.SS "check_logfile"
+.IX Subsection "check_logfile"
+This method just checks if the inode has changed of the currently opened
+file and the file that is found on the file system. If logrotate moved
+the file, then the inode changed. In this case the rotated file is read
+until its end and then the file will be closed to re-open the new file
+on the file system.
+.ie n .SS "pull(lines => $number)"
+.el .SS "pull(lines => \f(CW$number\fP)"
+.IX Subsection "pull(lines => $number)"
+This methods reads the excepted number of lines or until the end of the
+file and returns the lines as a array reference.
+.SS "validate"
+.IX Subsection "validate"
+Validate the configuration that is passed to the \f(CW\*(C`new\*(C'\fR constructor.
+.SS "log"
+.IX Subsection "log"
+Just a accessor to the logger.
+.SH "PREREQUISITES"
+.IX Header "PREREQUISITES"
+.Vb 3
+\&    Fcntl
+\&    Params::Validate
+\&    Log::Handler
+.Ve
+.SH "EXPORTS"
+.IX Header "EXPORTS"
+No exports.
+.SH "REPORT BUGS"
+.IX Header "REPORT BUGS"
+Please report all bugs to <support(at)bloonix.de>.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Jonny Schulz <support(at)bloonix.de>.
+.SH "COPYRIGHT"
+.IX Header "COPYRIGHT"
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
--- /dev/null
+++ awesant-0.7/perl/blib/libdoc/Awesant::Agent.3pm
@@ -0,0 +1,287 @@
+.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "Awesant::Agent 3pm"
+.TH Awesant::Agent 3pm "2013-02-03" "perl v5.10.1" "User Contributed Perl Documentation"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+Awesant::Agent \- Ships log files for logstash.
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+.Vb 4
+\&    Awesant::Agent\->run(
+\&        config  => $path_to_configuration,
+\&        pidfile => $path_to_pid_file,
+\&    );
+.Ve
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+Awesant is a simple log file shipper for logstash.
+.PP
+It ships log files and sends the data to different transports.
+.PP
+All what you have to do is to call the method \f(CW\*(C`run\*(C'\fR with its expected options.
+.SH "METHODS"
+.IX Header "METHODS"
+.SS "run"
+.IX Subsection "run"
+Start the shipping machine.
+.PP
+Nothing more is there for you to do. That means that you shouldn't touch the
+other methods in this module.
+.SS "load_output"
+.IX Subsection "load_output"
+Load the output modules that are used by configuration.
+.PP
+As example if \f(CW\*(C`redis\*(C'\fR is defined as transport in the output section
+.PP
+.Vb 5
+\&    output {
+\&        redis {
+\&            ...
+\&        }
+\&    }
+.Ve
+.PP
+then Awesant is looking for a module called \f(CW\*(C`Awesant::Output::Redis\*(C'\fR.
+If you would define a section call \f(CW\*(C`foo\*(C'\fR, then Awesant would try to
+\&\f(CW\*(C`require\*(C'\fR the module \f(CW\*(C`Awesant::Output::Foo\*(C'\fR.
+.SS "load_input"
+.IX Subsection "load_input"
+The method \f(CW\*(C`load_input\*(C'\fR does in the first step the same like \f(CW\*(C`load_output\*(C'\fR.
+It looks for input modules. As example if the input \f(CW\*(C`file\*(C'\fR is configured,
+then it tries to load the module \f(CW\*(C`Awesant::Input::File\*(C'\fR.
+.PP
+As next each output module that was pre-loaded is bound to the inputs.
+This is done using the parameter \f(CW\*(C`type\*(C'\fR.
+.SS "load_module"
+.IX Subsection "load_module"
+This method just includes the input and output modules and is called by
+\&\f(CW\*(C`load_output\*(C'\fR and \f(CW\*(C`load_input\*(C'\fR. The process to load the modules is really
+simple.
+.PP
+As example if the following sections are configured:
+.PP
+.Vb 5
+\&    output {
+\&        redis {
+\&            ...
+\&        }
+\&    }
+.Ve
+.PP
+then the module is loaded as follows:
+.PP
+.Vb 2
+\&    my $input_or_output = "output"; # output is the first section
+\&    my $transport = "redis";        # redis is the configured transport
+\&
+\&    my $module = join("::",
+\&        "Awesant",
+\&        ucfirst($input_or_output),
+\&        ucfirst($transport)
+\&    );
+\&
+\&    require $module;
+.Ve
+.PP
+All clear? :\-)
+.SS "daemonize"
+.IX Subsection "daemonize"
+Start the endless loop and calls \f(CW\*(C`run_agent\*(C'\fR in an eval block.
+.SS "run_agent"
+.IX Subsection "run_agent"
+This method is just a wrapper and calls \f(CW\*(C`run_log_shipper\*(C'\fR in an eval block.
+.SS "run_server"
+.IX Subsection "run_server"
+This methods creates some process groups for each input and just calls \f(CW\*(C`run_agent\*(C'\fR
+for each group after the workers are forked.
+.SS "run_log_shipper"
+.IX Subsection "run_log_shipper"
+The main logic of the Awesant agent. It requests the inputs for data to
+forward the data to the outputs.
+.SS "prepare_message"
+.IX Subsection "prepare_message"
+Each log line is passed to \f(CW\*(C`prepare_message\*(C'\fR and a nice formatted
+\&\s-1JSON\s0 string is returned, ready for Logstash.
+.SS "reap_children"
+.IX Subsection "reap_children"
+Reap died sub processes.
+.SS "spawn_children"
+.IX Subsection "spawn_children"
+Fork new children if less children than the configured workers are running.
+.SS "kill_children"
+.IX Subsection "kill_children"
+Kill all children on signal term.
+.SS "sig_child_handler"
+.IX Subsection "sig_child_handler"
+A handler to reap children.
+.SS "get_config"
+.IX Subsection "get_config"
+Load the configuration from a file.
+.SS "write_pidfile"
+.IX Subsection "write_pidfile"
+Writes the \s-1PID\s0 file.
+.SS "remove_pidfile"
+.IX Subsection "remove_pidfile"
+Removes the \s-1PID\s0 file.
+.SS "create_logger"
+.IX Subsection "create_logger"
+Create the logger object. As logger \f(CW\*(C`Log::Handler\*(C'\fR is used.
+.SS "validate_config, validate_agent_config, validate_add_field_match"
+.IX Subsection "validate_config, validate_agent_config, validate_add_field_match"
+Validate the configuration.
+.SS "config"
+.IX Subsection "config"
+Just an accessor to the configuration.
+.SS "log"
+.IX Subsection "log"
+Just an accessor to the logger.
+.SH "PREREQUISITES"
+.IX Header "PREREQUISITES"
+.Vb 7
+\&    Log::Handler
+\&    Params::Validate
+\&    JSON
+\&    POSIX
+\&    Sys::Hostname
+\&    Time::HiRes
+\&    Class::Accessor::Fast
+.Ve
+.SH "EXPORTS"
+.IX Header "EXPORTS"
+No exports.
+.SH "REPORT BUGS"
+.IX Header "REPORT BUGS"
+Please report all bugs to <support(at)bloonix.de>.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Jonny Schulz <support(at)bloonix.de>.
+.SH "COPYRIGHT"
+.IX Header "COPYRIGHT"
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
--- /dev/null
+++ awesant-0.7/perl/blib/libdoc/Awesant::Input::Socket.3pm
@@ -0,0 +1,257 @@
+.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "Awesant::Input::Socket 3pm"
+.TH Awesant::Input::Socket 3pm "2013-02-03" "perl v5.10.1" "User Contributed Perl Documentation"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+Awesant::Input::Socket \- Listen on TCP and/or UDP sockets and ship logs for logstash.
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+.Vb 8
+\&    Awesant::Input::Socket\->new(
+\&        host => "127.0.0.1",
+\&        port => 12345,
+\&        proto => "tcp"
+\&        ssl_ca_file => "/path/to/your.ca",
+\&        ssl_cert_file => "/path/to/your.crt",
+\&        ssl_key_file => "/path/to/your.key",
+\&    );
+\&
+\&    # lines = max lines
+\&    # It may be less.
+\&    $input\->pull(lines => 100);
+.Ve
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+Listen on a \s-1TCP\s0 or \s-1UDP\s0 socket and ship events.
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+.SS "host"
+.IX Subsection "host"
+The ip address to listen on.
+.PP
+Default: 127.0.0.1
+.SS "port"
+.IX Subsection "port"
+The port number to listen on.
+.PP
+Default: no default
+.SS "auth"
+.IX Subsection "auth"
+With this option it's possible to set a username and password if you want
+that each client have to authorize.
+.PP
+.Vb 1
+\&    user:password
+.Ve
+.PP
+See also the documentation of Awesant::Output::Socket.
+.SS "proto"
+.IX Subsection "proto"
+The protocol to use. At the moment only tcp is allowed.
+.PP
+Default: tcp
+.SS "ssl_ca_file, ssl_cert_file, ssl_key_file"
+.IX Subsection "ssl_ca_file, ssl_cert_file, ssl_key_file"
+If you want to use ssl connections then you can set the path to your ca, certificate and key file.
+.PP
+This options are equivalent to the options of IO::Socket::SSL.
+.PP
+See cpan http://search.cpan.org/~sullr/IO\-Socket\-SSL/.
+.PP
+Default: no default
+.SS "response"
+.IX Subsection "response"
+Send a response for each received event.
+.PP
+.Vb 1
+\&    response => "ok"
+.Ve
+.PP
+Then the string \*(L"ok\*(R" is send back to the sender.
+.PP
+See also the documentation of Awesant::Output::Socket.
+.SH "METHODS"
+.IX Header "METHODS"
+.SS "new"
+.IX Subsection "new"
+Create a new input object.
+.ie n .SS "pull(lines => $number)"
+.el .SS "pull(lines => \f(CW$number\fP)"
+.IX Subsection "pull(lines => $number)"
+This method tries to read the given number of lines of each client connection.
+.PP
+It may be less lines.
+.SS "open_socket"
+.IX Subsection "open_socket"
+Open the listen sockets for \s-1TCP\s0 and \s-1UDP\s0.
+.SS "close_socket"
+.IX Subsection "close_socket"
+Close the socket.
+.SS "select"
+.IX Subsection "select"
+Just an accessor to the selector object.
+.SS "socket"
+.IX Subsection "socket"
+Just an accessor to the socket object.
+.SS "config"
+.IX Subsection "config"
+Just an accessor to the config object.
+.SS "log"
+.IX Subsection "log"
+Just an accessor to the logger object.
+.SS "validate"
+.IX Subsection "validate"
+Validate the configuration.
+.SH "PREREQUISITES"
+.IX Header "PREREQUISITES"
+.Vb 4
+\&    Log::Handler
+\&    Params::Validate
+\&    IO::Socket::INET
+\&    IO::Select
+.Ve
+.PP
+For \s-1SSL\s0 only:
+.PP
+.Vb 1
+\&    IO::Socket::SSL
+.Ve
+.SH "EXPORTS"
+.IX Header "EXPORTS"
+No exports.
+.SH "REPORT BUGS"
+.IX Header "REPORT BUGS"
+Please report all bugs to <support(at)bloonix.de>.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Jonny Schulz <support(at)bloonix.de>.
+.SH "COPYRIGHT"
+.IX Header "COPYRIGHT"
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
--- /dev/null
+++ awesant-0.7/perl/blib/libdoc/Awesant::Output::Socket.3pm
@@ -0,0 +1,263 @@
+.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "Awesant::Output::Socket 3pm"
+.TH Awesant::Output::Socket 3pm "2013-02-03" "perl v5.10.1" "User Contributed Perl Documentation"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+Awesant::Output::Socket \- Send messages to a tcp socket.
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+.Vb 5
+\&    my $output = Awesant::Output::Socket\->new(
+\&        host => "127.0.0.1",
+\&        port => 4711,
+\&        timeout => 10,
+\&    );
+\&
+\&    $output\->push($line);
+.Ve
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+This transport module connects to a tcp socket and ships data plain or via ssl.
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+.SS "host"
+.IX Subsection "host"
+The hostname or ip address of the tcp server.
+.PP
+It's possible to set a comma separated list of failover hosts.
+.PP
+.Vb 4
+\&    socket {
+\&        host active\-server, failover\-server\-1, failover\-server\-2
+\&        port 4711
+\&    }
+.Ve
+.PP
+If the connection to one host failed then a connection to the next server is established.
+.PP
+Default: 127.0.0.1
+.SS "port"
+.IX Subsection "port"
+The port number where the tcp server is listen on.
+.PP
+Default: no default
+.SS "auth"
+.IX Subsection "auth"
+With this option it's possible to set a username and password, if you want to
+authorize the connection to the host.
+.PP
+.Vb 1
+\&    user:password
+.Ve
+.PP
+See also the documentation of Awesant::Input::Socket.
+.SS "timeout"
+.IX Subsection "timeout"
+The timeout in seconds to transport data to the tcp server.
+.PP
+Default: 10
+.SS "connect_timeout"
+.IX Subsection "connect_timeout"
+The timeout in seconds to connect to the tcp server.
+.PP
+Default: 10
+.SS "proto"
+.IX Subsection "proto"
+The protocol to use. At the moment only tcp is allowed.
+.PP
+Default: tcp
+.SS "response"
+.IX Subsection "response"
+If a response is excepted then you can set the excepted message here as a perl regular expression.
+.PP
+If the regular expression matched, then the transport of the message was successful.
+.PP
+Example:
+.PP
+.Vb 1
+\&    response ^(ok|yes|accept)$
+.Ve
+.PP
+Default: no default
+.PP
+See also the documentation of Awesant::Input::Socket.
+.SS "persistent"
+.IX Subsection "persistent"
+Use persistent connections or not.
+.PP
+Default: yes
+.SS "ssl_ca_file, ssl_cert_file, ssl_key_file"
+.IX Subsection "ssl_ca_file, ssl_cert_file, ssl_key_file"
+If you want to use ssl connections to the server you can set the path to your ca, certificate and key file.
+.PP
+This options are equivalent to the options of IO::Socket::SSL.
+.PP
+See cpan http://search.cpan.org/~sullr/IO\-Socket\-SSL/.
+.PP
+Default: no default
+.SH "METHODS"
+.IX Header "METHODS"
+.SS "new"
+.IX Subsection "new"
+Create a new output object.
+.SS "connect"
+.IX Subsection "connect"
+Connect to the tcp server.
+.SS "disconnect"
+.IX Subsection "disconnect"
+Disconnect from the socket.
+.SS "push"
+.IX Subsection "push"
+Push data to the tcp server.
+.SS "validate"
+.IX Subsection "validate"
+Validate the configuration that is passed to the \f(CW\*(C`new\*(C'\fR constructor.
+.SS "log"
+.IX Subsection "log"
+Just a accessor to the logger.
+.SH "PREREQUISITES"
+.IX Header "PREREQUISITES"
+.Vb 3
+\&    IO::Socket::INET
+\&    Log::Handler
+\&    Params::Validate
+.Ve
+.SH "EXPORTS"
+.IX Header "EXPORTS"
+No exports.
+.SH "REPORT BUGS"
+.IX Header "REPORT BUGS"
+Please report all bugs to <support(at)bloonix.de>.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Jonny Schulz <support(at)bloonix.de>.
+.SH "COPYRIGHT"
+.IX Header "COPYRIGHT"
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
--- /dev/null
+++ awesant-0.7/perl/blib/libdoc/Awesant::Config.3pm
@@ -0,0 +1,234 @@
+.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "Awesant::Config 3pm"
+.TH Awesant::Config 3pm "2013-02-03" "perl v5.10.1" "User Contributed Perl Documentation"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+Awesant::Config \- Configuration file parser.
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+.Vb 1
+\&    my $config = Awesant::Config\->parse($file);
+.Ve
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+This module is just for internal usage.
+.SH "CONFIGURATION FORMAT"
+.IX Header "CONFIGURATION FORMAT"
+.SS "SELF-EXPLANATORY"
+.IX Subsection "SELF-EXPLANATORY"
+The configuration format is very simple:
+.PP
+.Vb 8
+\&    param1 value
+\&    param2 value
+\&    param3 " value value value "
+\&    param4 \*(Aq value value value \*(Aq
+\&    param5 multiline \e
+\&           value
+\&    param6 " multiline values " \e
+\&           " with whitespaces "
+\&
+\&    section1 {
+\&        param1 value
+\&        param2 value
+\&
+\&        subsection1 {
+\&            param1 value
+\&            param2 value
+\&        }
+\&    }
+.Ve
+.SS "\s-1COMMENTS\s0"
+.IX Subsection "COMMENTS"
+Add comments to the configuration to explain parameter:
+.PP
+.Vb 8
+\&    # Comment
+\&    param1 value # comment
+\&    param2 value#value # comment
+\&    param3 \*(Aqvalue \e# value\*(Aq # comment
+\&    param4 multiline \e # comment
+\&           value
+\&    param5 " multiline values " \e # comment
+\&           " with whitespaces " # comment
+.Ve
+.SS "\s-1HASHES\s0 \s-1VS\s0 \s-1ARRRAYS\s0"
+.IX Subsection "HASHES VS ARRRAYS"
+Please note that if a hash key exists that the values will be pushed into an array:
+.PP
+.Vb 3
+\&    param1 value
+\&    param2 value1
+\&    param2 value2
+\&
+\&    section1 {
+\&        param value
+\&    }
+\&    section2 {
+\&        param value
+\&    }
+\&    section2 {
+\&        param value
+\&    }
+.Ve
+.PP
+is
+.PP
+.Vb 7
+\&    param1 => "value",
+\&    param2 => [ "value1", "value2" ],
+\&    section1 => { param => "value" },
+\&    section2 => [
+\&        { param => "value" },
+\&        { param => "value" }
+\&    ]
+.Ve
+.SH "FUNCTIONS"
+.IX Header "FUNCTIONS"
+.ie n .SS """parse"""
+.el .SS "\f(CWparse\fP"
+.IX Subsection "parse"
+Pass the configuration file as argument and a hash reference with the
+parsed configuration will be returned.
+.SH "PREREQUISITES"
+.IX Header "PREREQUISITES"
+No prerequisites.
+.SH "EXPORTS"
+.IX Header "EXPORTS"
+No exports.
+.SH "REPORT BUGS"
+.IX Header "REPORT BUGS"
+Please report all bugs to <support(at)bloonix.de>.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Jonny Schulz <support(at)bloonix.de>.
+.SH "COPYRIGHT"
+.IX Header "COPYRIGHT"
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
--- /dev/null
+++ awesant-0.7/perl/blib/libdoc/Awesant::Output::Redis.3pm
@@ -0,0 +1,217 @@
+.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "Awesant::Output::Redis 3pm"
+.TH Awesant::Output::Redis 3pm "2013-02-03" "perl v5.10.1" "User Contributed Perl Documentation"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+Awesant::Output::Redis \- Send messages to a Redis database.
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+.Vb 7
+\&    my $output = Awesant::Output::Redis\->new(
+\&        host => "127.0.0.1",
+\&        port => 6379,
+\&        timeout => 20,
+\&        database => 0,
+\&        password => "secret",
+\&    );
+\&
+\&    $output\->push($line);
+.Ve
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+This transport module connects to a Redis database and ships data via \s-1LPUSH\s0.
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+.SS "host"
+.IX Subsection "host"
+The hostname or ip address of the Redis server.
+.PP
+Default: 127.0.0.1
+.SS "port"
+.IX Subsection "port"
+The port number where the Redis server is listen on.
+.PP
+Default: 6379
+.SS "timeout"
+.IX Subsection "timeout"
+The timeout in seconds to connect and transport data to the Redis server.
+.PP
+Default: 10
+.SS "database"
+.IX Subsection "database"
+The database to select.
+.PP
+Default: 0
+.SS "password"
+.IX Subsection "password"
+The password to use for authentication.
+.PP
+Default: not set
+.SS "key"
+.IX Subsection "key"
+The key is mandatory and is used to transport the data. This key is necessary for logstash to pull the data from the Redis database.
+.PP
+Default: not set
+.SH "METHODS"
+.IX Header "METHODS"
+.SS "new"
+.IX Subsection "new"
+Create a new output object.
+.SS "connect"
+.IX Subsection "connect"
+Connect to the redis database.
+.SS "push"
+.IX Subsection "push"
+Push data to redis via \s-1LPUSH\s0 command.
+.SS "validate"
+.IX Subsection "validate"
+Validate the configuration that is passed to the \f(CW\*(C`new\*(C'\fR constructor.
+.SS "log"
+.IX Subsection "log"
+Just a accessor to the logger.
+.SH "PREREQUISITES"
+.IX Header "PREREQUISITES"
+.Vb 3
+\&    IO::Socket::INET
+\&    Log::Handler
+\&    Params::Validate
+.Ve
+.SH "EXPORTS"
+.IX Header "EXPORTS"
+No exports.
+.SH "REPORT BUGS"
+.IX Header "REPORT BUGS"
+Please report all bugs to <support(at)bloonix.de>.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Jonny Schulz <support(at)bloonix.de>.
+.SH "COPYRIGHT"
+.IX Header "COPYRIGHT"
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
--- /dev/null
+++ awesant-0.7/perl/blib/libdoc/Awesant::Output::Screen.3pm
@@ -0,0 +1,189 @@
+.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "Awesant::Output::Screen 3pm"
+.TH Awesant::Output::Screen 3pm "2013-02-03" "perl v5.10.1" "User Contributed Perl Documentation"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+Awesant::Output::Screen \- Send messages to the screen.
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+.Vb 3
+\&    my $log = Awesant::Format::Screen\->new(
+\&        send_to => "stdout"
+\&    );
+.Ve
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+.SS "send_to"
+.IX Subsection "send_to"
+Where to send the output.
+.PP
+Possible:
+.PP
+.Vb 3
+\&    stderr
+\&    stdout
+\&    null (means /dev/null)
+.Ve
+.PP
+Default: null
+.SH "METHODS"
+.IX Header "METHODS"
+.SS "new"
+.IX Subsection "new"
+Create a new input object.
+.SS "push"
+.IX Subsection "push"
+Push data to \s-1STDOUT\s0, \s-1STDERR\s0 or to \f(CW\*(C`/dev/null\*(C'\fR.
+.SS "validate"
+.IX Subsection "validate"
+Validate the configuration that is passed to the \f(CW\*(C`new\*(C'\fR constructor.
+.SS "log"
+.IX Subsection "log"
+Just a accessor to the logger.
+.SH "PREREQUISITES"
+.IX Header "PREREQUISITES"
+.Vb 2
+\&    Log::Handler
+\&    Params::Validate
+.Ve
+.SH "EXPORTS"
+.IX Header "EXPORTS"
+No exports.
+.SH "REPORT BUGS"
+.IX Header "REPORT BUGS"
+Please report all bugs to <support(at)bloonix.de>.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Jonny Schulz <support(at)bloonix.de>.
+.SH "COPYRIGHT"
+.IX Header "COPYRIGHT"
+Copyright (C) 2012 by Jonny Schulz. All rights reserved.
--- /dev/null
+++ awesant-0.7/etc/init.d/awesant-agent
@@ -0,0 +1,117 @@
+#!/bin/sh
+
+### BEGIN INIT INF
+# Provides:         awesant
+# Required-Start:   $all
+# Required-Stop:    $all
+# Default-Start:    2 3 4 5
+# Default-Stop:     0 1 6
+# Short-Description: Starts awesant agent
+# chkconfig: 2345 80 15
+# Description: Awesant services
+### END INIT INFO
+
+BASENAME=$(basename $0)
+CONFIG=/etc/awesant/agent.conf
+RUNDIR=/var/run/awesant
+PIDFILE=$RUNDIR/agent.pid
+DAEMON=/usr/bin/awesant
+
+[ -f /etc/sysconfig/$BASENAME ] && . /etc/sysconfig/$BASENAME
+[ -f /etc/default/$BASENAME ] && . /etc/default/$BASENAME
+
+if test ! -d "$RUNDIR" ; then
+    mkdir -p $RUNDIR
+fi
+
+__check_awesant_agent() {
+    DAEMON_EXIST=""
+    if test -e "$PIDFILE" ; then
+        DAEMON_PID=$(cat $PIDFILE 2>/dev/null)
+        if test -n "$DAEMON_PID" ; then
+            DAEMON_EXIST=$(ps $DAEMON_PID | grep awesant)
+        fi
+    fi
+}
+
+__start() {
+    echo -n "Starting ${BASENAME}: "
+    if test -z "$DAEMON_EXIST" ; then
+        $DAEMON --config "$CONFIG" --pidfile "$PIDFILE" &
+
+        for i in `seq 1 3` ; do
+            __check_awesant_agent
+            if test ! -z "$DAEMON_EXIST" ; then
+                break
+            fi
+            sleep 1
+        done
+
+        if test -z "$DAEMON_EXIST" ; then
+            echo "awesant failed to start"
+            RETVAL=1
+        else
+            echo "awesant started successfully, PID $DAEMON_PID"
+            RETVAL=0
+        fi
+    else
+        echo "awesant-agent already running"
+        RETVAL=0
+    fi
+}
+
+__stop() {
+    echo -n "Stopping ${BASENAME}: "
+    if test -z "$DAEMON_EXIST" ; then
+        echo "awesant-agent not running"
+        RETVAL=0
+    else
+        kill -15 $DAEMON_PID
+
+        for i in `seq 1 15` ; do
+            __check_awesant_agent
+            if test -z "$DAEMON_EXIST" ; then
+                break
+            fi
+            sleep 1
+        done
+
+        if test -z "$DAEMON_EXIST" ; then
+            echo "awesant-agent stopped successfully"
+            RETVAL=0
+            rm -f ${PIDFILE}
+        else
+            echo "ERR: awesant-agent was not stopped successfully, PID $DAEMON_PID"
+            RETVAL=1
+        fi
+    fi
+    return $RETVAL
+}
+
+__status() {
+    echo -n "Status ${BASENAME}: "
+    if test -z "$DAEMON_EXIST" ; then
+        echo "awesant-agent is not running"
+        RETVAL=1
+    else
+        echo "awesant-agent is running, PID $DAEMON_PID"
+        RETVAL=0
+    fi
+}
+
+__usage() {
+    echo "Usage: $BASENAME {start|stop|restart}"
+    RETVAL=1
+}
+
+__check_awesant_agent
+
+case "$1" in
+    start   ) __start ;;
+    stop    ) __stop ;;
+    status  ) __status ;;
+    restart ) __stop && __start ;;
+    *       ) __usage ;;
+esac
+
+exit $RETVAL
--- /dev/null
+++ awesant-0.7/etc/awesant/agent.conf
@@ -0,0 +1,30 @@
+input {
+    file {
+        type syslog
+        path /var/log/messages
+    }
+}
+
+output {
+    #redis {
+    #    type syslog
+    #    key syslog
+    #    host 127.0.0.1
+    #    port 6379
+    #    database 0
+    #}
+    screen {
+        type syslog
+        send_to stderr
+    }
+}
+
+logger {
+    #file {
+    #    filename /var/log/awesant/agent.log
+    #    maxlevel info
+    #}
+    screen {
+        maxlevel info
+    }
+}
